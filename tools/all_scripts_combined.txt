==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private int currentNodeIndex = 0;

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        HashSet<int> selectedPromptIndices = new HashSet<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            selectedPromptIndices.Add(randomIndex);
        }

        foreach (int index in selectedPromptIndices)
        {
            var prompt = prompts[index];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = "" }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }

        // Link the last response to the "Reflection" node
        generatedNodes[^1].choices[0].next_node = "Reflection";
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    void Start()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

    public void StartNode(string nodeId)
    {
        if (string.IsNullOrEmpty(nodeId))
        {
            Debug.LogError("Attempted to start a node with an empty ID.");
            return;
        }

        if (nodeId == "MainQuestions")
        {
            mainQuestionsHandler?.StartMainQuestionsSequence();
            return;
        }

        if (dialogueNodes.ContainsKey(nodeId))
        {
            currentNode = dialogueNodes[nodeId];
            dialogueUI.RefreshView(currentNode, this);
        }
        else
        {
            Debug.LogError($"Node with ID '{nodeId}' not found.");
        }
    }

    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

    public string GetBodyText()
    {
        if (body_text is string singleText)
        {
            return singleText;
        }
        else if (body_text is List<object> textList && textList.Count > 0)
        {
            return textList[Random.Range(0, textList.Count)].ToString();
        }
        return null;
    }

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] possiblePaths =
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/MainPrompts_{nodeId}",
            $"sounds/voice/PromptResponses_{nodeId}",
            $"sounds/voice/Continue_{nodeId}"
        };

        AudioClip clip = null;
        foreach (string path in possiblePaths)
        {
            clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                Debug.Log($"Playing voice file: {path}");
                break;
            }
        }

        if (clip != null)
        {
            audioSource.clip = clip;
            audioSource.Play();
            StartCoroutine(WaitForAudio(onComplete));
        }
        else
        {
            Debug.Log($"No voice file found for node ID: {nodeId} in any expected format.");
            onComplete?.Invoke();
        }
    }

    IEnumerator WaitForAudio(System.Action onComplete)
    {
        yield return new WaitForSeconds(audioSource.clip.length);
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.Log($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.Log("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private int currentNodeIndex = 0;

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        HashSet<int> selectedPromptIndices = new HashSet<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            selectedPromptIndices.Add(randomIndex);
        }

        foreach (int index in selectedPromptIndices)
        {
            var prompt = prompts[index];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = "" }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }

        // Link the last response to the "Reflection" node
        generatedNodes[^1].choices[0].next_node = "Reflection";
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    void Start()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

    public void StartNode(string nodeId)
    {
        if (string.IsNullOrEmpty(nodeId))
        {
            Debug.LogError("Attempted to start a node with an empty ID.");
            return;
        }

        if (nodeId == "MainQuestions")
        {
            mainQuestionsHandler?.StartMainQuestionsSequence();
            return;
        }

        if (dialogueNodes.ContainsKey(nodeId))
        {
            currentNode = dialogueNodes[nodeId];
            dialogueUI.RefreshView(currentNode, this);
        }
        else
        {
            Debug.LogError($"Node with ID '{nodeId}' not found.");
        }
    }

    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] possiblePaths =
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/MainPrompts_{nodeId}",
            $"sounds/voice/PromptResponses_{nodeId}",
            $"sounds/voice/Continue_{nodeId}"
        };

        AudioClip clip = null;
        foreach (string path in possiblePaths)
        {
            clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                Debug.Log($"Playing voice file: {path}");
                break;
            }
        }

        if (clip != null)
        {
            audioSource.clip = clip;
            audioSource.Play();
            StartCoroutine(WaitForAudio(onComplete));
        }
        else
        {
            Debug.Log($"No voice file found for node ID: {nodeId} in any expected format.");
            onComplete?.Invoke();
        }
    }

    IEnumerator WaitForAudio(System.Action onComplete)
    {
        yield return new WaitForSeconds(audioSource.clip.length);
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.Log($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.Log("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private int currentNodeIndex = 0;

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        HashSet<int> selectedPromptIndices = new HashSet<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            selectedPromptIndices.Add(randomIndex);
        }

        foreach (int index in selectedPromptIndices)
        {
            var prompt = prompts[index];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = "" }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }

        // Link the last response to the "Reflection" node
        generatedNodes[^1].choices[0].next_node = "Reflection";
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] possiblePaths =
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/MainPrompts_{nodeId}",
            $"sounds/voice/PromptResponses_{nodeId}",
            $"sounds/voice/Continue_{nodeId}"
        };

        AudioClip clip = null;
        foreach (string path in possiblePaths)
        {
            clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                Debug.Log($"Playing voice file: {path}");
                break;
            }
        }

        if (clip != null)
        {
            audioSource.clip = clip;
            audioSource.Play();
            StartCoroutine(WaitForAudio(onComplete));
        }
        else
        {
            Debug.Log($"No voice file found for node ID: {nodeId} in any expected format.");
            onComplete?.Invoke();
        }
    }

    IEnumerator WaitForAudio(System.Action onComplete)
    {
        yield return new WaitForSeconds(audioSource.clip.length);
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.Log($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.Log("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private int currentNodeIndex = 0;

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        HashSet<int> selectedPromptIndices = new HashSet<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            selectedPromptIndices.Add(randomIndex);
        }

        foreach (int index in selectedPromptIndices)
        {
            var prompt = prompts[index];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = "" }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }

        // Link the last response to the "Reflection" node
        generatedNodes[^1].choices[0].next_node = "Reflection";
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool isFirstMainPrompt = true;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] possiblePaths =
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        AudioClip clip = null;
        foreach (string path in possiblePaths)
        {
            clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                Debug.Log($"Playing voice file: {path}");
                break;
            }
        }

        if (clip != null)
        {
            if (nodeId.StartsWith("MainPrompts_") && isFirstMainPrompt)
            {
                StartCoroutine(PlayFirstMainPromptSequence(clip, onComplete));
            }
            else
            {
                StartCoroutine(PlayClip(clip, onComplete));
            }
        }
        else
        {
            Debug.Log($"No voice file found for node ID: {nodeId} in any expected format.");
            onComplete?.Invoke();
        }
    }

    IEnumerator PlayFirstMainPromptSequence(AudioClip promptClip, System.Action onComplete)
    {
        audioSource.clip = promptClip;
        audioSource.Play();
        yield return new WaitForSeconds(audioSource.clip.length);

        AudioClip scannerClip = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
        if (scannerClip != null)
        {
            Debug.Log("Playing SCANNER_PROMPT.wav");
            audioSource.clip = scannerClip;
            audioSource.Play();
            yield return new WaitForSeconds(audioSource.clip.length);
        }

        isFirstMainPrompt = false;
        onComplete?.Invoke();
    }

    IEnumerator PlayClip(AudioClip clip, System.Action onComplete)
    {
        audioSource.clip = clip;
        audioSource.Play();
        yield return new WaitForSeconds(audioSource.clip.length);
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.Log($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.Log("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class LEDAnimation
{
    public string name;
    public Color32 startColor = new Color32(255, 255, 255, 255);  // Default white
    public Color32 endColor = new Color32(255, 255, 255, 255);    // Default white
    public string type = "fade";  // Default animation type (fade or flicker)
    public int duration = 1000;   // Default duration in milliseconds

    public string ToCommandString()
    {
        return $"{type},{startColor.r},{startColor.g},{startColor.b},{startColor.a}," +
               $"{endColor.r},{endColor.g},{endColor.b},{endColor.a},{duration}\n";
    }
}

public class LEDAnimator : MonoBehaviour
{
    [Header("Palm Scanner Reference")]
    public PalmScanner palmScanner;  // Reference to the PalmScanner script

    [Header("LED Animations")]
    public List<LEDAnimation> ledAnimations = new List<LEDAnimation>();

    void Start()
    {
        // Automatically find the PalmScanner if not set in Inspector
        if (palmScanner == null)
        {
            palmScanner = FindObjectOfType<PalmScanner>();
        }

        if (palmScanner == null)
        {
            Debug.LogError("PalmScanner script not found in the scene. Please attach it.");
        }
    }

    // Public method to start an LED animation by name
    public void PlayAnimation(string animationName)
    {
        LEDAnimation animation = ledAnimations.Find(a => a.name == animationName);

        if (animation != null)
        {
            string command = animation.ToCommandString();
            SendCommandToPalmScanner(command);
            Debug.Log($"Playing LED animation: {animationName}");
        }
        else
        {
            Debug.LogError($"LED animation with name '{animationName}' not found.");
        }
    }

    // Send the animation command to PalmScanner script
    private void SendCommandToPalmScanner(string command)
    {
        if (palmScanner != null && palmScanner.IsConnected())
        {
            palmScanner.TriggerLEDAnimation(command);
        }
        else
        {
            Debug.LogError("PalmScanner is not connected. Cannot send LED animation command.");
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.Log($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.Log("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class LEDAnimation
{
    public string name;
    public Color32 startColor = new Color32(255, 255, 255, 255);  // Default white
    public Color32 endColor = new Color32(255, 255, 255, 255);    // Default white
    public string type = "fade";  // Default animation type (fade or flicker)
    public int duration = 1000;   // Default duration in milliseconds

    public string ToCommandString()
    {
        return $"{type},{startColor.r},{startColor.g},{startColor.b},{startColor.a}," +
               $"{endColor.r},{endColor.g},{endColor.b},{endColor.a},{duration}\n";
    }
}

public class LEDAnimator : MonoBehaviour
{
    [Header("Palm Scanner Reference")]
    public PalmScanner palmScanner;  // Reference to the PalmScanner script

    [Header("LED Animations")]
    public List<LEDAnimation> ledAnimations = new List<LEDAnimation>();

    void Start()
    {
        // Automatically find the PalmScanner if not set in Inspector
        if (palmScanner == null)
        {
            palmScanner = FindObjectOfType<PalmScanner>();
        }

        if (palmScanner == null)
        {
            Debug.LogError("PalmScanner script not found in the scene. Please attach it.");
        }
    }

    // Public method to start an LED animation by name
    public void PlayAnimation(string animationName)
    {
        LEDAnimation animation = ledAnimations.Find(a => a.name == animationName);

        if (animation != null)
        {
            string command = animation.ToCommandString();
            SendCommandToPalmScanner(command);
            Debug.Log($"Playing LED animation: {animationName}");
        }
        else
        {
            Debug.LogError($"LED animation with name '{animationName}' not found.");
        }
    }

    // Send the animation command to PalmScanner script
    private void SendCommandToPalmScanner(string command)
    {
        if (palmScanner != null && palmScanner.IsConnected())
        {
            palmScanner.TriggerLEDAnimation(command);
        }
        else
        {
            Debug.LogError("PalmScanner is not connected. Cannot send LED animation command.");
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    public bool IsConnected()
{
    return serialPort != null && serialPort.IsOpen;
}


    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.Log($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

public void TriggerLEDAnimation(string command)
{
    if (serialPort != null && serialPort.IsOpen && scannerEnabled)
    {
        serialPort.WriteLine(command);
        Debug.Log($"Sent LED animation command: {command}");
    }
    else
    {
        Debug.Log("Cannot send LED animation. Serial port is not connected.");
    }
}


    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class LEDAnimation
{
    public string name;
    public Color32 startColor = new Color32(255, 255, 255, 255);  // Default white
    public Color32 endColor = new Color32(255, 255, 255, 255);    // Default white
    public string type = "fade";  // Default animation type (fade or flicker)
    public int duration = 1000;   // Default duration in milliseconds

    public string ToCommandString()
    {
        return $"{type},{startColor.r},{startColor.g},{startColor.b},{startColor.a}," +
               $"{endColor.r},{endColor.g},{endColor.b},{endColor.a},{duration}\n";
    }
}

public class LEDAnimator : MonoBehaviour
{
    [Header("Palm Scanner Reference")]
    public PalmScanner palmScanner;  // Reference to the PalmScanner script

    [Header("LED Animations")]
    public List<LEDAnimation> ledAnimations = new List<LEDAnimation>();

    void Start()
    {
        // Automatically find the PalmScanner if not set in Inspector
        if (palmScanner == null)
        {
            palmScanner = FindObjectOfType<PalmScanner>();
        }

        if (palmScanner == null)
        {
            Debug.LogError("PalmScanner script not found in the scene. Please attach it.");
        }
    }

    // Public method to start an LED animation by name
    public void PlayAnimation(string animationName)
    {
        LEDAnimation animation = ledAnimations.Find(a => a.name == animationName);

        if (animation != null)
        {
            string command = animation.ToCommandString();
            SendCommandToPalmScanner(command);
            Debug.Log($"Playing LED animation: {animationName}");
        }
        else
        {
            Debug.LogError($"LED animation with name '{animationName}' not found.");
        }
    }

    // Send the animation command to PalmScanner script
    private void SendCommandToPalmScanner(string command)
    {
        if (palmScanner != null && palmScanner.IsConnected())
        {
            palmScanner.TriggerLEDAnimation(command);
        }
        else
        {
            Debug.LogError("PalmScanner is not connected. Cannot send LED animation command.");
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    public bool IsConnected()
{
    return serialPort != null && serialPort.IsOpen;
}


    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.Log($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

public void TriggerLEDAnimation(string command)
{
    if (serialPort != null && serialPort.IsOpen && scannerEnabled)
    {
        serialPort.WriteLine(command);
        Debug.Log($"Sent LED animation command: {command}");
    }
    else
    {
        Debug.Log("Cannot send LED animation. Serial port is not connected.");
    }
}


    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using UnityEngine;
using System.Collections.Generic;

[System.Serializable]
public class LEDAnimation
{
    public string name;
    public Color32 startColor = new Color32(255, 255, 255, 255);  // Default white
    public Color32 endColor = new Color32(255, 255, 255, 255);    // Default white
    public string type = "fade";  // Default animation type (fade or flicker)
    public int duration = 1000;   // Default duration in milliseconds

    public string ToCommandString()
    {
        return $"{type},{startColor.r},{startColor.g},{startColor.b},{startColor.a}," +
               $"{endColor.r},{endColor.g},{endColor.b},{endColor.a},{duration}\n";
    }
}

public class LEDAnimator : MonoBehaviour
{
    [Header("Palm Scanner Reference")]
    public PalmScanner palmScanner;  // Reference to the PalmScanner script

    [Header("LED Animations")]
    public List<LEDAnimation> ledAnimations = new List<LEDAnimation>();

    void Start()
    {
        // Automatically find the PalmScanner if not set in Inspector
        if (palmScanner == null)
        {
            palmScanner = FindObjectOfType<PalmScanner>();
        }

        if (palmScanner == null)
        {
            Debug.LogError("PalmScanner script not found in the scene. Please attach it.");
        }
    }

    // Public method to start an LED animation by name
    public void PlayAnimation(string animationName)
    {
        LEDAnimation animation = ledAnimations.Find(a => a.name == animationName);

        if (animation != null)
        {
            string command = animation.ToCommandString();
            SendCommandToPalmScanner(command);
            Debug.Log($"Playing LED animation: {animationName}");
        }
        else
        {
            Debug.LogError($"LED animation with name '{animationName}' not found.");
        }
    }

    // Send the animation command to PalmScanner script
    private void SendCommandToPalmScanner(string command)
    {
        if (palmScanner != null && palmScanner.IsConnected())
        {
            palmScanner.TriggerLEDAnimation(command);
        }
        else
        {
            Debug.LogError("PalmScanner is not connected. Cannot send LED animation command.");
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    public bool IsConnected()
    {
        return serialPort != null && serialPort.IsOpen;
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;

            if (isConnected)
            {
                Debug.Log($"Palm Scanner connected on {portName}");
                StartCoroutine(FindDialogueManager());
            }
            else
            {
                Debug.LogError("Palm Scanner failed to connect.");
            }

            UpdateIconColor();
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = IsConnected();
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && IsConnected())
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"Error reading from serial port: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                    serialPort = null;
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
        }

        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton.gameObject.activeInHierarchy)
            {
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }
    }

    public void TriggerLEDAnimation(string command)
    {
        if (IsConnected() && scannerEnabled)
        {
            serialPort.WriteLine(command);
            Debug.Log($"Sent LED animation command: {command}");
        }
        else
        {
            Debug.Log("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = IsConnected() ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private DialogueManager dialogueManager;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
            UpdateIconColor();
            StartCoroutine(FindDialogueManager());
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.Log($"Failed to open serial port: {ex.Message}");
            UpdateIconColor();
        }
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    private IEnumerator FindDialogueManager()
    {
        while (dialogueManager == null)
        {
            dialogueManager = FindObjectOfType<DialogueManager>();
            yield return new WaitForSeconds(1f);
        }
    }

    void Update()
    {
        if (scannerEnabled && serialPort != null && serialPort.IsOpen)
        {
            try
            {
                if (serialPort.BytesToRead > 0)
                {
                    string receivedData = serialPort.ReadLine().Trim();
                    Debug.Log($"Palm Scanner received: {receivedData}");

                    if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                    {
                        ProcessButtonPress(receivedData);
                    }
                }
            }
            catch (System.IO.IOException ex)
            {
                Debug.LogError($"IO Exception: {ex.Message}");
            }
            catch (System.Exception ex)
            {
                Debug.LogError($"Unexpected error: {ex.Message}");
            }
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager != null && dialogueManager.gameObject.activeInHierarchy)
        {
            if (dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
            {
                Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
                dialogueManager.HandleChoiceSelection(receivedData);
                return;
            }
        }

        SkipButton[] skipButtons = FindObjectsOfType<SkipButton>(true);
        foreach (var skipButton in skipButtons)
        {
            if (skipButton != null && skipButton.gameObject.activeInHierarchy)
            {
                Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                skipButton.HandlePalmScannerInput(receivedData);
                return;
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.Log("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }


    public bool IsConnected()
    {
        return serialPort != null && serialPort.IsOpen;
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    public DialogueManager dialogueManager;
    public SkipButton[] skipButtons;  // Public array to assign skip buttons manually
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    void Update()
    {
        if (!scannerEnabled || serialPort == null || !serialPort.IsOpen)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                Debug.Log($"Palm Scanner received: {receivedData}");

                if (!string.IsNullOrEmpty(receivedData) && (receivedData == "1" || receivedData == "2"))
                {
                    ProcessButtonPress(receivedData);
                }
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error reading from serial port: {ex.Message}");
        }

        if (Input.GetKeyDown(KeyCode.P))
        {
            scannerEnabled = !scannerEnabled;
            if (scannerEnabled)
            {
                Debug.Log("Palm Scanner re-enabled.");
                TryInitializeScanner();
            }
            else
            {
                Debug.Log("Palm Scanner disabled.");
                if (serialPort != null && serialPort.IsOpen)
                {
                    serialPort.Close();
                }
            }
        }
    }

    void ProcessButtonPress(string receivedData)
    {
        if (dialogueManager == null)
        {
            Debug.LogError("DialogueManager reference is not assigned in the inspector.");
            return;
        }

        if (dialogueManager.dialogueUI != null && dialogueManager.dialogueUI.choiceContainer.gameObject.activeSelf)
        {
            Debug.Log($"Sending choice selection to DialogueManager: {receivedData}");
            dialogueManager.HandleChoiceSelection(receivedData);
            return;
        }

        if (skipButtons != null && skipButtons.Length > 0)
        {
            foreach (var skipButton in skipButtons)
            {
                if (skipButton != null && skipButton.gameObject.activeInHierarchy)
                {
                    Debug.Log($"Palm scanner triggering SkipButton with input: {receivedData}");
                    skipButton.HandlePalmScannerInput(receivedData);
                    return;
                }
            }
        }

        Debug.LogWarning("No valid target found for palm scanner input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.LogError("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        if (receivedData == "1" || receivedData == "2")
        {
            Debug.Log($"Palm scanner input received: {receivedData}");
            TriggerButton();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;
using System.Collections;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    public DialogueManager dialogueManager;
    public SkipButton[] skipButtons;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private bool isConnected = false;
    private bool scannerEnabled = true;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("Palm Scanner connected.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    void Update()
    {
        if (!scannerEnabled || serialPort == null || !serialPort.IsOpen)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1" || receivedData == "2")
                {
                    TriggerSkipButton(receivedData);
                }
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error reading from serial port: {ex.Message}");
        }

        HandleKeyboardInput();
    }

    void HandleKeyboardInput()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            Debug.Log("Keyboard input detected: 1");
            TriggerSkipButton("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            Debug.Log("Keyboard input detected: 2");
            TriggerSkipButton("2");
        }
    }

    void TriggerSkipButton(string input)
    {
        if (skipButtons != null && skipButtons.Length > 0)
        {
            foreach (var skipButton in skipButtons)
            {
                if (skipButton != null && skipButton.gameObject.activeInHierarchy)
                {
                    Debug.Log($"Triggering SkipButton with input: {input}");
                    skipButton.HandlePalmScannerInput(input);
                    return;
                }
            }
        }

        Debug.LogWarning("No active SkipButton found for input.");
    }

    public void TriggerLEDAnimation(int effectType)
    {
        if (serialPort != null && serialPort.IsOpen && scannerEnabled)
        {
            serialPort.WriteLine(effectType.ToString());
            Debug.Log($"Sent LED animation command: {effectType}");
        }
        else
        {
            Debug.LogError("Cannot send LED animation. Serial port is not connected.");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
        if (button == null)
        {
            Debug.LogError($"SkipButton on {gameObject.name} is missing a Button component.");
        }
    }

    void Start()
    {
        if (button != null)
        {
            button.onClick.AddListener(() => Debug.Log($"Button {gameObject.name} clicked."));
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            Debug.Log($"Button {gameObject.name} triggered via script.");
            button.onClick.Invoke();
        }
        else
        {
            Debug.LogWarning($"Button {gameObject.name} is not interactable.");
        }
    }

    public void HandlePalmScannerInput(string receivedData)
    {
        Debug.Log($"Palm scanner input received: {receivedData} for button {gameObject.name}");
        TriggerButton();
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using System.Diagnostics;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            UnityEngine.Debug.Log("Palm Scanner connected successfully.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    SimulateKeyPress("1");
                }
                else if (receivedData == "2")
                {
                    SimulateKeyPress("2");
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }
    }

    void SimulateKeyPress(string key)
    {
        Process process = new Process();
        process.StartInfo.FileName = "/bin/bash";
        process.StartInfo.Arguments = $"-c \"xdotool key {key}\"";
        process.StartInfo.RedirectStandardOutput = true;
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.CreateNoWindow = true;
        process.Start();
        process.WaitForExit();
        UnityEngine.Debug.Log($"Simulated key press: {key}");
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.green : Color.red;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;
    public LightFader ScannerEffect;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
                ScannerEffect.StartLightFade(2);
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;

    void Awake()
    {
        button = GetComponent<Button>();
        if (button != null)
        {
            button.onClick.AddListener(TriggerButton);
        }
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1))
            {
                UnityEngine.Debug.Log("Keyboard input detected: 1");
                TriggerButton();
            }
            else if (Input.GetKeyDown(KeyCode.Alpha2))
            {
                UnityEngine.Debug.Log("Keyboard input detected: 2");
                TriggerButton();
            }
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            UnityEngine.Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using System.Collections;
using UnityEngine.UI;
using System.Diagnostics;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeScanner();
        StartCoroutine(CheckConnectionStatus());
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            UnityEngine.Debug.Log("Palm Scanner connected successfully.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    private IEnumerator CheckConnectionStatus()
    {
        while (true)
        {
            isConnected = serialPort != null && serialPort.IsOpen;
            UpdateIconColor();
            yield return new WaitForSeconds(2f);
        }
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    SimulateKeyPress("1");
                }
                else if (receivedData == "2")
                {
                    SimulateKeyPress("2");
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }
    }

    void SimulateKeyPress(string key)
    {
        Process process = new Process();
        process.StartInfo.FileName = "/bin/bash";
        process.StartInfo.Arguments = $"-c \"xdotool key {key}\"";
        process.StartInfo.RedirectStandardOutput = true;
        process.StartInfo.UseShellExecute = false;
        process.StartInfo.CreateNoWindow = true;
        process.Start();
        process.WaitForExit();
        UnityEngine.Debug.Log($"Simulated key press: {key}");
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.green : Color.red;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;
    public LightFader ScannerEffect;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
                ScannerEffect.StartLightFade(2);
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button button;
    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Awake()
    {
        button = GetComponent<Button>();
        if (button != null)
        {
            button.onClick.AddListener(TriggerButton);
        }
    }

    void Update()
    {
        if (button != null && button.interactable)
        {
            if (Input.GetKeyDown(KeyCode.Alpha1) || (PalmScanner.button1Pressed && !previousButton1State))
            {
                UnityEngine.Debug.Log("Button 1 triggered via keyboard or scanner.");
                TriggerButton();
                PalmScanner.button1Pressed = false; // Reset after press
            }

            if (Input.GetKeyDown(KeyCode.Alpha2) || (PalmScanner.button2Pressed && !previousButton2State))
            {
                UnityEngine.Debug.Log("Button 2 triggered via keyboard or scanner.");
                TriggerButton();
                PalmScanner.button2Pressed = false; // Reset after press
            }

            // Update previous states
            previousButton1State = PalmScanner.button1Pressed;
            previousButton2State = PalmScanner.button2Pressed;
        }
    }

    public void TriggerButton()
    {
        if (button != null && button.interactable)
        {
            UnityEngine.Debug.Log($"Button {button.name} triggered.");
            button.onClick.Invoke();
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;  // Ensure this is included for LINQ operations

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;
    public static bool button1Pressed = false;
    public static bool button2Pressed = false;

    void Start()
    {
        TryInitializeScanner();
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            UnityEngine.Debug.Log("Palm Scanner connected successfully.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    button1Pressed = true;
                }
                else if (receivedData == "2")
                {
                    button2Pressed = true;
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.green : Color.red;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;
    public LightFader ScannerEffect;

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        Debug.Log($"Enabling {choices.Count} choices.");
        
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<UnityEngine.UI.Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
                ScannerEffect.StartLightFade(2);
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button skipButton;
    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Awake()
    {
        skipButton = GetComponent<Button>();
        if (skipButton == null)
        {
            Debug.LogError("SkipButton script requires a Button component on the same GameObject.");
        }
    }

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            PressButton();
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            PressButton();
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    void PressButton()
    {
        if (skipButton != null)
        {
            skipButton.onClick.Invoke();
            Debug.Log("SkipButton pressed via keyboard input.");
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;

    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

   private void HandleChoiceSelection(string buttonPressed)
{
    if (dialogueManager.CurrentNode != null)
    {
        foreach (var choice in dialogueManager.CurrentNode.choices)
        {
            if (choice.button == buttonPressed)
            {
                Debug.Log($"Button {buttonPressed} pressed. Proceeding to node: {choice.next_node}");
                dialogueManager.StartNode(choice.next_node);
                return;
            }
        }
    }
    else
    {
        Debug.LogWarning("No current node to handle choice selection.");
    }
}


    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;
    public static bool button1Pressed = false;
    public static bool button2Pressed = false;

    void Start()
    {
        TryInitializeScanner();
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            UnityEngine.Debug.Log("Palm Scanner connected successfully.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    button1Pressed = true;
                }
                else if (receivedData == "2")
                {
                    button2Pressed = true;
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.green : Color.red;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
           // PalmScanner.button1Pressed = false;
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
            PalmScanner.button2Pressed = false;
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }

    void HandleChoiceSelection(string buttonPressed)
    {
        foreach (Transform child in choiceContainer)
        {
            Button button = child.GetComponent<Button>();
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();

            if (buttonText.text.Contains($"[{buttonPressed}]"))
            {
                Debug.Log($"Simulating click for button: {buttonPressed}");
                button.onClick.Invoke();
                return;
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button skipButton;
    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Awake()
    {
        skipButton = GetComponent<Button>();
        if (skipButton == null)
        {
            Debug.LogError("SkipButton script requires a Button component on the same GameObject.");
        }
    }

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            PressButton();
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            PressButton();
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    void PressButton()
    {
        if (skipButton != null)
        {
            skipButton.onClick.Invoke();
            Debug.Log("SkipButton pressed via keyboard input.");
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;

    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

private void HandleChoiceSelection(string buttonPressed)
{
    DialogueNode currentNode = dialogueManager.GetCurrentNode();
    if (currentNode != null)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == buttonPressed)
            {
                Debug.Log($"Button {buttonPressed} pressed. Proceeding to node: {choice.next_node}");
                dialogueManager.StartNode(choice.next_node);
                return;
            }
        }
    }
    else
    {
        Debug.LogWarning("No current node available to handle choice selection.");
    }
}





    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }


public DialogueNode GetCurrentNode()
{
    return currentNode;
}

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;
    public static bool button1Pressed = false;
    public static bool button2Pressed = false;

    void Start()
    {
        TryInitializeScanner();
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
            UnityEngine.Debug.Log("Palm Scanner connected successfully.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    button1Pressed = true;
                }
                else if (receivedData == "2")
                {
                    button2Pressed = true;
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.green : Color.red;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
           // PalmScanner.button1Pressed = false;
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
            PalmScanner.button2Pressed = false;
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {
        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
    }

    void HandleChoiceSelection(string buttonPressed)
    {
        foreach (Transform child in choiceContainer)
        {
            Button button = child.GetComponent<Button>();
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();

            if (buttonText.text.Contains($"[{buttonPressed}]"))
            {
                Debug.Log($"Simulating click for button: {buttonPressed}");
                button.onClick.Invoke();
                return;
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
          // Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button skipButton;
    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Awake()
    {
        skipButton = GetComponent<Button>();
        if (skipButton == null)
        {
            Debug.LogError("SkipButton script requires a Button component on the same GameObject.");
        }
    }

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            PressButton();
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            PressButton();
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    void PressButton()
    {
        if (skipButton != null)
        {
            skipButton.onClick.Invoke();
            //Debug.Log("SkipButton pressed via keyboard input.");
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;

    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1) 
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}" 
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

private void HandleChoiceSelection(string buttonPressed)
{
    DialogueNode currentNode = dialogueManager.GetCurrentNode();
    if (currentNode != null)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == buttonPressed)
            {
                Debug.Log($"Button {buttonPressed} pressed. Proceeding to node: {choice.next_node}");
                dialogueManager.StartNode(choice.next_node);
                return;
            }
        }
    }
    else
    {
        Debug.LogWarning("No current node available to handle choice selection.");
    }
}





    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }


public DialogueNode GetCurrentNode()
{
    return currentNode;
}

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;
    public static bool button1Pressed = false;
    public static bool button2Pressed = false;
    private float button1ResetTime;
    private float button2ResetTime;
    private const float resetDelay = 0.5f;

    void Start()
    {
        TryInitializeScanner();
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    button1Pressed = true;
                    button1ResetTime = Time.time + resetDelay;
                }
                else if (receivedData == "2")
                {
                    button2Pressed = true;
                    button2ResetTime = Time.time + resetDelay;
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }

        if (button1Pressed && Time.time >= button1ResetTime)
        {
            button1Pressed = false;
        }

        if (button2Pressed && Time.time >= button2ResetTime)
        {
            button2Pressed = false;
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.yellow : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    private bool ChoicesEnabled = false;

    void Update()
    {

         if (ChoicesEnabled && choiceContainer.childCount > 0) // Ensure the container has at least one button
    {
            if (PalmScanner.button1Pressed && !previousButton1State)
            {
                previousButton1State = true;
                HandleChoiceSelection("1");
            }
            else if (!PalmScanner.button1Pressed)
            {
                previousButton1State = false;
            }

            if (PalmScanner.button2Pressed && !previousButton2State)
            {
                previousButton2State = true;
                HandleChoiceSelection("2");
            }
            else if (!PalmScanner.button2Pressed)
            {
                previousButton2State = false;
            }
        }
    }

    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

    void ClearChoices()
    {
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
        ChoicesEnabled = false;
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {

        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
        ChoicesEnabled = true;
    }

    void HandleChoiceSelection(string buttonPressed)
    {

        Debug.Log("==============================================/n Tried to press button for " + buttonPressed);

        foreach (Transform child in choiceContainer)
        {
            Button button = child.GetComponent<Button>();
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();

Debug.Log("buttonText.text.Contains($\"[{buttonPressed}]\")) " + buttonText.text.Contains($"[{buttonPressed}]")) ;
            if (buttonText.text.Contains($"[{buttonPressed}]"))
            {
                Debug.Log($"Simulating click for button: {buttonPressed}");
                button.onClick.Invoke();
                return;
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
          // Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button skipButton;
    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Awake()
    {
        skipButton = GetComponent<Button>();
        if (skipButton == null)
        {
            Debug.LogError("SkipButton script requires a Button component on the same GameObject.");
        }
    }

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            PressButton();
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            PressButton();
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    void PressButton()
    {
        if (skipButton != null)
        {
            skipButton.onClick.Invoke();
            //Debug.Log("SkipButton pressed via keyboard input.");
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;
using System.Linq;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;

    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        generatedNodes.Clear();

        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        List<int> selectedPromptIndices = new List<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            if (!selectedPromptIndices.Contains(randomIndex))
            {
                selectedPromptIndices.Add(randomIndex);
            }
        }

        for (int i = 0; i < selectedPromptIndices.Count; i++)
        {
            var prompt = prompts[selectedPromptIndices[i]];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            string nextNode = (i < selectedPromptIndices.Count - 1)
                ? $"MainPrompts_{prompts[selectedPromptIndices[i + 1]].id}"
                : "Reflection";

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "[1] Continue", button = "1", next_node = nextNode }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    private void HandleChoiceSelection(string buttonPressed)
    {
        DialogueNode currentNode = dialogueManager.GetCurrentNode();
        if (currentNode != null)
        {
            foreach (var choice in currentNode.choices)
            {
                if (choice.button == buttonPressed)
                {
                    Debug.Log($"Button {buttonPressed} pressed. Proceeding to node: {choice.next_node}");
                    dialogueManager.StartNode(choice.next_node);
                    return;
                }
            }
        }
        else
        {
            Debug.LogWarning("No current node available to handle choice selection.");
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

  public void StartNode(string nodeId)
{
    if (string.IsNullOrEmpty(nodeId))
    {
        Debug.LogError("Attempted to start a node with an empty ID.");
        return;
    }

    if (nodeId == "MainQuestions")
    {
        mainQuestionsHandler?.StartMainQuestionsSequence();
        return;
    }

    if (dialogueNodes.ContainsKey(nodeId))
    {
        currentNode = dialogueNodes[nodeId];
        dialogueUI.RefreshView(currentNode, this);
    }
    else
    {
        Debug.LogError($"Node with ID '{nodeId}' not found.");
    }
}
    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }


public DialogueNode GetCurrentNode()
{
    return currentNode;
}

    public void HandleChoiceSelection(string button)
    {
        foreach (var choice in currentNode.choices)
        {
            if (choice.button == button)
            {
                StartNode(choice.next_node);
                return;
            }
        }
        Debug.LogWarning($"No choice found for button {button}");
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;
    public static bool button1Pressed = false;
    public static bool button2Pressed = false;
    private float button1ResetTime;
    private float button2ResetTime;
    private const float resetDelay = 2f;

    void Start()
    {
        TryInitializeScanner();
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    button1Pressed = true;
                    button1ResetTime = Time.time + resetDelay;
                }
                else if (receivedData == "2")
                {
                    button2Pressed = true;
                    button2ResetTime = Time.time + resetDelay;
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }

        if (button1Pressed && Time.time >= button1ResetTime)
        {
            button1Pressed = false;
        }

        if (button2Pressed && Time.time >= button2ResetTime)
        {
            button2Pressed = false;
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.yellow : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    private bool ChoicesEnabled = false;

 void Update()
{
    if ( choiceContainer.gameObject.activeInHierarchy)
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }
}


    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        choiceContainer.gameObject.SetActive(false);
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

void Start(){
    choiceContainer.gameObject.SetActive(false);
}
    void ClearChoices()
    {
        choiceContainer.gameObject.SetActive(false);
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {

        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
          choiceContainer.gameObject.SetActive(true);
    }

    void HandleChoiceSelection(string buttonPressed)
    {

        Debug.Log("==============================================/n Tried to press button for " + buttonPressed);

        foreach (Transform child in choiceContainer)
        {
            Button button = child.GetComponent<Button>();
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();

Debug.Log("buttonText.text.Contains($\"[{buttonPressed}]\")) " + buttonText.text.Contains($"[{buttonPressed}]")) ;
            if (buttonText.text.Contains($"[{buttonPressed}]"))
            {
                Debug.Log($"Simulating click for button: {buttonPressed}");
                button.onClick.Invoke();
                choiceContainer.gameObject.SetActive(false);
                return;
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
          // Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button skipButton;
    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Awake()
    {
        skipButton = GetComponent<Button>();
        if (skipButton == null)
        {
            Debug.LogError("SkipButton script requires a Button component on the same GameObject.");
        }
    }

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            PressButton();
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            PressButton();
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    void PressButton()
    {
        if (skipButton != null)
        {
            skipButton.onClick.Invoke();
            //Debug.Log("SkipButton pressed via keyboard input.");
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private int currentNodeIndex = 0;

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
        else
        {
            Debug.LogError("Failed to generate nodes for MainQuestions sequence.");
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        HashSet<int> selectedPromptIndices = new HashSet<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            selectedPromptIndices.Add(randomIndex);
        }

        foreach (int index in selectedPromptIndices)
        {
            var prompt = prompts[index];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2 â€” choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "Continue", button = "1", next_node = "" }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);
        }

        // Link the last response to the "Reflection" node
        generatedNodes[^1].choices[0].next_node = "Reflection";
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

    public void StartNode(string nodeId)
    {
        if (string.IsNullOrEmpty(nodeId))
        {
            Debug.LogError("Attempted to start a node with an empty ID.");
            return;
        }

        if (nodeId == "MainQuestions")
        {
            mainQuestionsHandler?.StartMainQuestionsSequence();
            return;
        }

        if (dialogueNodes.ContainsKey(nodeId))
        {
            currentNode = dialogueNodes[nodeId];
            dialogueUI.RefreshView(currentNode, this);
        }
        else
        {
            Debug.LogError($"Node with ID '{nodeId}' not found.");
        }
    }

    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        if (dialogueUI != null && dialogueUI.choiceContainer.gameObject.activeSelf)
        {
            foreach (var choice in currentNode.choices)
            {
                if (choice.button == button)
                {
                    StartNode(choice.next_node);
                    return;
                }
            }
            Debug.LogWarning($"No choice found for button {button}");
        }
        else if (currentNode != null && currentNode.id.StartsWith("MainPrompts"))
        {
            foreach (var choice in currentNode.choices)
            {
                if (choice.button == button)
                {
                    StartNode(choice.next_node);
                    return;
                }
            }
            Debug.LogWarning($"No choice found for button {button} in MainQuestionsHandler");
        }
        else
        {
            Debug.Log("Choice selection attempted while buttons are not visible.");
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;
    public static bool button1Pressed = false;
    public static bool button2Pressed = false;
    private float button1ResetTime;
    private float button2ResetTime;
    private const float resetDelay = 2f;

    void Start()
    {
        TryInitializeScanner();
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    button1Pressed = true;
                    button1ResetTime = Time.time + resetDelay;
                }
                else if (receivedData == "2")
                {
                    button2Pressed = true;
                    button2ResetTime = Time.time + resetDelay;
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }

        if (button1Pressed && Time.time >= button1ResetTime)
        {
            button1Pressed = false;
        }

        if (button2Pressed && Time.time >= button2ResetTime)
        {
            button2Pressed = false;
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.yellow : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    private bool ChoicesEnabled = false;

 void Update()
{
    if ( choiceContainer.gameObject.activeInHierarchy)
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }
}


    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        choiceContainer.gameObject.SetActive(false);
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

void Start(){
    choiceContainer.gameObject.SetActive(false);
}
    void ClearChoices()
    {
        choiceContainer.gameObject.SetActive(false);
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {

        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
          choiceContainer.gameObject.SetActive(true);
    }

    void HandleChoiceSelection(string buttonPressed)
    {

        Debug.Log("==============================================/n Tried to press button for " + buttonPressed);

        foreach (Transform child in choiceContainer)
        {
            Button button = child.GetComponent<Button>();
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();

Debug.Log("buttonText.text.Contains($\"[{buttonPressed}]\")) " + buttonText.text.Contains($"[{buttonPressed}]")) ;
            if (buttonText.text.Contains($"[{buttonPressed}]"))
            {
                Debug.Log($"Simulating click for button: {buttonPressed}");
                button.onClick.Invoke();
                choiceContainer.gameObject.SetActive(false);
                return;
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

==== START OF ..//Assets/Scripts/DisableOnStart.cs ====
using UnityEngine;

public class DisableOnStart : MonoBehaviour
{
  
    void Start()
    {
        gameObject.SetActive(false);
    }

  
}

==== END OF ..//Assets/Scripts/DisableOnStart.cs ====

==== START OF ..//Assets/Scripts/EventAfterWait.cs ====
using System.Collections;
using UnityEngine;
using UnityEngine.Events;

public class EventAfterWait : MonoBehaviour
{
    [Header("Settings")]
    public float waitTime = 1.0f; // Time to wait before invoking the event
    public bool triggerOnStart = false; // Whether the event should trigger automatically on Start

    [Header("Event")]
    public UnityEvent onWaitCompleted; // Unity Event to trigger after the wait

    private Coroutine waitCoroutine;
    private bool isCancelled = false;

    private void Start()
    {
        if (triggerOnStart)
        {
            StartWaiting();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            CancelWaiting();
            onWaitCompleted?.Invoke();
        }
    }

    /// <summary>
    /// Starts the wait timer and triggers the event after the specified time.
    /// </summary>
    public void StartWaiting()
    {
        isCancelled = false;
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
        }
        waitCoroutine = StartCoroutine(WaitAndTrigger());
    }

    /// <summary>
    /// Cancels the waiting coroutine if it is running.
    /// </summary>
    public void CancelWaiting()
    {
        if (waitCoroutine != null)
        {
            StopCoroutine(waitCoroutine);
            waitCoroutine = null;
            isCancelled = true;
        }
    }

    private IEnumerator WaitAndTrigger()
    {
        yield return new WaitForSeconds(waitTime);
        
        if (!isCancelled)
        {
            onWaitCompleted?.Invoke();
        }

        waitCoroutine = null;
    }
}

==== END OF ..//Assets/Scripts/EventAfterWait.cs ====

==== START OF ..//Assets/Scripts/LEDAnimator.cs ====
using System.IO.Ports;
using UnityEngine;

public class LEDAnimator : MonoBehaviour
{
    public string portName = "/dev/ttyUSB0";
    public int baudRate = 9600;
    private SerialPort serialPort;
    private bool isConnected = false;

    void Start()
    {
        TryInitializeSerialPort();
    }

    void TryInitializeSerialPort()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
          // Debug.Log("LED Animator connected to serial port.");
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
    }

    public void SendLEDCommand(string command)
    {
        if (isConnected && serialPort != null && serialPort.IsOpen)
        {
            if (int.TryParse(command, out int commandValue))
            {
                serialPort.WriteLine(commandValue.ToString());
                Debug.Log($"Sent LED command: {commandValue}");
            }
            else
            {
                Debug.LogError($"Invalid command format: {command}");
            }
        }
        else
        {
            Debug.LogError("Serial port is not connected.");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SendLEDCommand("1");
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SendLEDCommand("2");
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/LEDAnimator.cs ====

==== START OF ..//Assets/Scripts/EventOnActive.cs ====
using UnityEngine;
using UnityEngine.Events;

public class EventOnActive : MonoBehaviour
{
    public UnityEvent OnActive;
    void Awake()
    {
        OnActive.Invoke();
    }

 
}

==== END OF ..//Assets/Scripts/EventOnActive.cs ====

==== START OF ..//Assets/Scripts/TalkingLights.cs ====
using System.Collections;
using UnityEngine;

public class TalkingLights : MonoBehaviour
{
    public float syllableInterval = 0.3f; // Time interval for each syllable
    public int mouthPatternCount = 4; // Adjustable number of mouth patterns to use (up to 4)
    private MaterialToggle[] lights; // Array to hold 6 MaterialToggle components
    private Coroutine talkingRoutine;

    private readonly string sampleText = "Hello, how are you today?";

    // Define four mouth patterns for lights
    private readonly int[][] mouthPatterns = new int[][]
    {
        new int[] { },              // Closed - no lights
        new int[] { 2, 3 },         // Small Open - middle two lights
        new int[] { 1, 2, 3, 4 },   // Medium Open - four lights in the middle
        new int[] { 0, 1, 2, 3, 4, 5 } // Wide Open - all lights on
    };

    void Start()
    {
        // Populate the lights array with MaterialToggle components from child objects
        lights = GetComponentsInChildren<MaterialToggle>();
        
        if (lights.Length != 6)
        {
            Debug.LogWarning("TalkingLights script requires exactly 6 MaterialToggle components.");
        }
        
        StartTalking(sampleText); // Start talking animation with sample text
    }

    public void StartTalking(string text)
    {
        // Stop any ongoing talking sequence
        if (talkingRoutine != null)
        {
            StopCoroutine(talkingRoutine);
        }
        talkingRoutine = StartCoroutine(TalkingSequence(text));
    }

    private IEnumerator TalkingSequence(string text)
    {
        // Break the text into syllables
        string[] syllables = BreakTextIntoSyllables(text);

        foreach (string syllable in syllables)
        {
            // Choose a random mouth pattern from the available set
            int patternIndex1 = Random.Range(0, mouthPatternCount);
            int patternIndex2 = Random.Range(0, mouthPatternCount);

            // Apply the first mouth shape
            int[] mouthShape1 = mouthPatterns[patternIndex1];
            ApplyMouthShape(mouthShape1);
            Console.Log($"Syllable: {syllable}, Mouth Shape 1: [{string.Join(", ", mouthShape1)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Half of the syllable interval

            // Apply the second mouth shape
            int[] mouthShape2 = mouthPatterns[patternIndex2];
            ApplyMouthShape(mouthShape2);
            Console.Log($"Syllable: {syllable}, Mouth Shape 2: [{string.Join(", ", mouthShape2)}]");
            yield return new WaitForSeconds(syllableInterval / 2); // Second half of the syllable interval

            // Turn off all lights briefly between syllables
            ToggleAllLights(false);
            Console.Log("Intermediate: All lights turned off after syllable.");
        }

        // Ensure all lights are off after the text sequence completes, with a slight delay
        yield return new WaitForSeconds(0.1f);
        ToggleAllLights(false);
        Console.Log("End of text sequence - All lights turned off.");
    }

    private string[] BreakTextIntoSyllables(string text)
    {
        // Basic syllable splitting example for demonstration (splits by individual words for simplicity)
        return text.Split(new char[] { ' ', '-', ',' }, System.StringSplitOptions.RemoveEmptyEntries);
    }

    private void ApplyMouthShape(int[] mouthShape)
    {
        // Turn off all lights first
        ToggleAllLights(false);

        // Turn on only the lights in the specified mouth shape pattern
        foreach (int index in mouthShape)
        {
            if (index >= 0 && index < lights.Length && lights[index] != null)
            {
                lights[index].SetToggleState(true);
            }
        }
    }

    private void ToggleAllLights(bool isOn)
    {
        foreach (var light in lights)
        {
            if (light != null)
            {
                light.SetToggleState(isOn);
            }
        }
    }
}

==== END OF ..//Assets/Scripts/TalkingLights.cs ====

==== START OF ..//Assets/Scripts/InkPlayer.cs ====
using UnityEngine;

public class InkPlayer : MonoBehaviour
{
   

    void Start()
    {
        
    }

}

==== END OF ..//Assets/Scripts/InkPlayer.cs ====

==== START OF ..//Assets/Scripts/SkipButton.cs ====
using UnityEngine;
using UnityEngine.UI;

public class SkipButton : MonoBehaviour
{
    private Button skipButton;
    private bool previousButton1State = false;
    private bool previousButton2State = false;

    void Awake()
    {
        skipButton = GetComponent<Button>();
        if (skipButton == null)
        {
            Debug.LogError("SkipButton script requires a Button component on the same GameObject.");
        }
    }

    void Update()
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            PressButton();
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            PressButton();
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }

    void PressButton()
    {
        if (skipButton != null)
        {
            skipButton.onClick.Invoke();
            //Debug.Log("SkipButton pressed via keyboard input.");
        }
    }
}

==== END OF ..//Assets/Scripts/SkipButton.cs ====

==== START OF ..//Assets/Scripts/DialogueLoader.cs ====
using System.Collections.Generic;
using UnityEngine;
using System.IO;
using Newtonsoft.Json;

public class DialogueLoader : MonoBehaviour
{
    public Dictionary<string, DialogueNode> LoadDialogue()
    {
        try
        {
            string filePath = Path.Combine(Application.dataPath, "Resources/dialogue.json");
            if (!File.Exists(filePath))
            {
                Debug.LogError($"Dialogue file not found at: {filePath}");
                return new Dictionary<string, DialogueNode>();
            }

            string json = File.ReadAllText(filePath);
            List<DialogueNode> nodesList = JsonConvert.DeserializeObject<List<DialogueNode>>(json);

            if (nodesList != null)
            {
                var dialogueNodes = new Dictionary<string, DialogueNode>();
                foreach (var node in nodesList)
                {
                    dialogueNodes[node.id] = node;
                }
                Debug.Log("Dialogue JSON loaded successfully.");
                return dialogueNodes;
            }
            else
            {
                Debug.LogError("Failed to parse dialogue JSON: No valid data found.");
                return new Dictionary<string, DialogueNode>();
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading dialogue JSON: {ex.Message}");
            return new Dictionary<string, DialogueNode>();
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueLoader.cs ====

==== START OF ..//Assets/Scripts/MouthController.cs ====
using UnityEngine;

public class MouthController : MonoBehaviour
{
    [Header("Audio Settings")]
    public AudioSource audioSource;
    [Range(0.1f, 10.0f)] public float sensitivity = 1.0f; // Adjusts responsiveness to audio
    [Range(0.0f, 1.0f)] public float threshold = 0.05f;  // Minimum value to trigger visuals

    [Header("Emission Settings")]
    [Range(0.0f, 10.0f)] public float maxEmissionIntensity = 5.0f; // Maximum emissive intensity
    [Range(5f, 15.0f)] public float fadeSpeed = 1.0f; // Fade speed when audio stops
    [Range(0.01f, 0.5f)] public float smoothness = 0.1f; // Smooth transition effect

    private Renderer[] childRenderers;
    private float[] samples = new float[512];
    private float[] frequencyBands = new float[6];
    private float[] bandBuffer = new float[6];
    private float[] bufferDecrease = new float[6];
    private Color baseEmissionColor;

    void Start()
    {
        // Get all child objects with a Renderer component
        childRenderers = GetComponentsInChildren<Renderer>();

        if (childRenderers.Length != 6)
        {
            Debug.LogError("MouthController requires exactly 6 child objects with Renderer components.");
        }

        // Get the default emissive color of the materials (assuming they are all the same)
        if (childRenderers.Length > 0)
        {
            baseEmissionColor = childRenderers[0].material.GetColor("_EmissionColor");
        }
    }

    void Update()
    {
        if (audioSource == null || !audioSource.isPlaying)
        {
            FadeToBlack();
            return;
        }

        AnalyzeAudio();
        UpdateBandBuffer();
        ApplyEqualizerVisualization();
    }

    void AnalyzeAudio()
    {
        // Get spectrum data from the audio source
        audioSource.GetSpectrumData(samples, 0, FFTWindow.Blackman);

        // Divide the spectrum into 6 frequency bands
        int count = 0;
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            float average = 0;
            int sampleCount = (int)Mathf.Pow(2, i) * 2;
            if (i == frequencyBands.Length - 1)
            {
                sampleCount += 2; // Add remaining samples to the last band
            }

            for (int j = 0; j < sampleCount; j++)
            {
                average += samples[count] * (count + 1);
                count++;
            }

            average /= count;
            frequencyBands[i] = Mathf.Max(0, average * sensitivity - threshold); // Apply sensitivity and threshold
        }
    }

    void UpdateBandBuffer()
    {
        // Smooth the frequency response with a buffer
        for (int i = 0; i < frequencyBands.Length; i++)
        {
            if (frequencyBands[i] > bandBuffer[i])
            {
                bandBuffer[i] = frequencyBands[i];
                bufferDecrease[i] = smoothness;
            }
            else
            {
                bandBuffer[i] -= bufferDecrease[i];
                bufferDecrease[i] *= 1.2f; // Increase buffer falloff speed
            }
        }
    }

    void ApplyEqualizerVisualization()
    {
        for (int i = 0; i < childRenderers.Length; i++)
        {
            float intensity = Mathf.Lerp(0, maxEmissionIntensity, bandBuffer[i]);
            SetEmission(childRenderers[i], intensity);
        }
    }

    void SetEmission(Renderer renderer, float intensity)
    {
        if (renderer != null)
        {
            Color emissionColor = baseEmissionColor * Mathf.LinearToGammaSpace(intensity);
            renderer.material.SetColor("_EmissionColor", emissionColor);
        }
    }

    void FadeToBlack()
    {
        // Gradually fade back to black when no audio is playing
        foreach (Renderer renderer in childRenderers)
        {
            Color currentEmission = renderer.material.GetColor("_EmissionColor");
            Color targetEmission = baseEmissionColor * Mathf.LinearToGammaSpace(0);
            renderer.material.SetColor("_EmissionColor", Color.Lerp(currentEmission, targetEmission, fadeSpeed * Time.deltaTime));
        }
    }
}

==== END OF ..//Assets/Scripts/MouthController.cs ====

==== START OF ..//Assets/Scripts/MainQuestionsHandler.cs ====
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using Newtonsoft.Json;

public class MainQuestionsHandler : MonoBehaviour
{
    public DialogueManager dialogueManager;
    private List<DialogueNode> generatedNodes = new List<DialogueNode>();
    private int currentNodeIndex = 0;

    private string promptsPath = "Resources/MainPrompts.json";
    private string responsesPath = "Resources/PromptResponses.json";

    public void StartMainQuestionsSequence()
    {
        LoadAndGenerateNodes();
        if (generatedNodes.Count > 0)
        {
            dialogueManager.InjectNodes(generatedNodes);
            dialogueManager.StartNode(generatedNodes[0].id);
        }
    }

    private void LoadAndGenerateNodes()
    {
        List<MainPrompt> prompts = LoadJsonData<MainPrompt>(promptsPath);
        List<PromptResponse> responses = LoadJsonData<PromptResponse>(responsesPath);

        if (prompts == null || responses == null || prompts.Count < 5)
        {
            Debug.LogError("Insufficient data for MainQuestions sequence.");
            return;
        }

        HashSet<int> selectedPromptIndices = new HashSet<int>();
        while (selectedPromptIndices.Count < 5)
        {
            int randomIndex = Random.Range(0, prompts.Count);
            selectedPromptIndices.Add(randomIndex);
        }

        DialogueNode previousResponseNode = null;

        foreach (int index in selectedPromptIndices)
        {
            var prompt = prompts[index];
            var response = responses[Random.Range(0, responses.Count)];

            var promptNode = new DialogueNode
            {
                id = $"MainPrompts_{prompt.id}",
                body_text = prompt.prompt + "\nPlace your left hand on the palm scanner. Then, use your right hand to press the button for option 1 or option 2â€”choose the one that feels right to you.",
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "1", button = "1", next_node = $"PromptResponses_{response.id}" },
                    new DialogueNode.Choice { text = "2", button = "2", next_node = $"PromptResponses_{response.id}" }
                },
                text_to_speech = true
            };

            var responseNode = new DialogueNode
            {
                id = $"PromptResponses_{response.id}",
                body_text = response.text,
                choices = new List<DialogueNode.Choice>
                {
                    new DialogueNode.Choice { text = "Continue", button = "1", next_node = "" }
                },
                text_to_speech = true
            };

            generatedNodes.Add(promptNode);
            generatedNodes.Add(responseNode);

            if (previousResponseNode != null)
            {
                previousResponseNode.choices[0].next_node = promptNode.id;
            }
            previousResponseNode = responseNode;
        }

        previousResponseNode.choices[0].next_node = "Reflection";
    }

    private List<T> LoadJsonData<T>(string filePath)
    {
        try
        {
            string fullPath = Path.Combine(Application.dataPath, filePath);
            string json = File.ReadAllText(fullPath);
            return JsonConvert.DeserializeObject<List<T>>(json);
        }
        catch (System.Exception ex)
        {
            Debug.LogError($"Error loading JSON from {filePath}: {ex.Message}");
            return null;
        }
    }

    [System.Serializable]
    public class MainPrompt
    {
        public int id;
        public string prompt;
    }

    [System.Serializable]
    public class PromptResponse
    {
        public string id;
        public string text;
    }
}

==== END OF ..//Assets/Scripts/MainQuestionsHandler.cs ====

==== START OF ..//Assets/Scripts/DialogueController.cs ====
using UnityEngine;
using TMPro;

public class DialogueController : MonoBehaviour
{
 
    public TMP_Text dialogueBoxTitle;
    public TMP_Text dialogueBoxBody;
    
    void Start()
    {
        dialogueBoxTitle.text = "Title Placeholder";
        dialogueBoxBody.text = "Dialogue body text goes here.";
    }

    void Update()
    {
        
    }

   
    public void SetDialogue(string title, string body)
    {
        dialogueBoxTitle.text = title;
        dialogueBoxBody.text = body;

    }
}

==== END OF ..//Assets/Scripts/DialogueController.cs ====

==== START OF ..//Assets/Scripts/SceneReloader.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class SceneReloader : MonoBehaviour
{
    public void RestartScene()
    {
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}
==== END OF ..//Assets/Scripts/SceneReloader.cs ====

==== START OF ..//Assets/Scripts/SubwooferController.cs ====
using UnityEngine;
using UnityEngine.UI;
using System.IO.Ports;
using System.Collections;
using System;

public class SubwooferController : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort = new SerialPort("/dev/ttyACM0", 9600);
    private bool isConnected = false;

    void Start()
    {
        try
        {
            serialPort.Open();
            isConnected = serialPort.IsOpen;
            UpdateIconColor();
        }
        catch (Exception)
        {
            isConnected = false;
            UpdateIconColor();
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Alpha3)) SendFrequency(50);
        if (Input.GetKeyDown(KeyCode.Alpha4)) SendFrequencySequence(new int[] { 50, 20, 50, 20, 50 }, 1000);
        if (Input.GetKeyDown(KeyCode.Alpha5)) SendFrequencySequence(new int[] { 30, 50, 70, 90, 110 }, 2000);
        if (Input.GetKeyDown(KeyCode.Alpha6)) SendFrequencySequence(new int[] { 100, 90, 80, 70, 60 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha7)) SendFrequencySequence(new int[] { 40, 80, 120, 80, 40 }, 6000);
        if (Input.GetKeyDown(KeyCode.Alpha8)) SendFrequencySequence(new int[] { 50, 55, 60, 65, 70 }, 4000);
        if (Input.GetKeyDown(KeyCode.Alpha9)) SendGlitchTone(50, 600, 5000, 200);
        if (Input.GetKeyDown(KeyCode.Alpha0)) SendRandomFrequencySequence(8, 10, 100, 2000);
        if (Input.GetKeyDown(KeyCode.Space)) SendFrequency(0);
    }

    void SendFrequency(int frequency)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine(frequency.ToString());
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendFrequencySequence(int[] frequencies, int duration)
    {
        StartCoroutine(PlayToneSequence(frequencies, duration));
    }

    IEnumerator PlayToneSequence(int[] frequencies, int duration)
    {
        int interval = duration / frequencies.Length;
        foreach (int freq in frequencies)
        {
            SendFrequency(freq);
            yield return new WaitForSeconds(interval / 1000f);
        }
        SendFrequency(0);
    }

    void SendGlitchTone(int minFreq, int maxFreq, int duration, int interval)
    {
        if (serialPort.IsOpen)
        {
            serialPort.WriteLine($"GLITCH {minFreq} {maxFreq} {duration} {interval}");
            StartCoroutine(FlashIconColor(Color.yellow, 1));
        }
    }

    void SendRandomFrequencySequence(int count, int minFreq, int maxFreq, int duration)
    {
        int[] randomFrequencies = new int[count];
        for (int i = 0; i < count; i++)
        {
            randomFrequencies[i] = UnityEngine.Random.Range(minFreq, maxFreq);
        }
        SendFrequencySequence(randomFrequencies, duration);
    }

    IEnumerator FlashIconColor(Color color, float duration)
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = color;
            yield return new WaitForSeconds(duration);
            UpdateIconColor();
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.white : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/SubwooferController.cs ====

==== START OF ..//Assets/Scripts/SoundManager.cs ====
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Audio;

public class SoundManager : MonoBehaviour
{
    public static SoundManager Instance;

    [System.Serializable]
    public class Sound
    {
        public string name;                      // Name of the sound
        public List<AudioClip> clips;           // List of audio clips
        public bool playInLeftChannel = true;   // Play in the left channel
        public bool playInRightChannel = true;  // Play in the right channel
    }

    [Header("Audio Setup")]
    public List<Sound> sounds;
    public AudioMixerGroup audioMixerGroup;

    private Dictionary<string, Sound> soundDictionary;

    private void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }

        InitializeSoundDictionary();
    }

    private void InitializeSoundDictionary()
    {
        soundDictionary = new Dictionary<string, Sound>();
        foreach (var sound in sounds)
        {
            soundDictionary[sound.name] = sound;
        }
    }

    public void PlaySound(string soundName)
    {
        if (soundDictionary.TryGetValue(soundName, out Sound sound))
        {
            if (sound.clips.Count > 0)
            {
                // Randomly select a clip
                AudioClip clipToPlay = sound.clips[Random.Range(0, sound.clips.Count)];

                // Spawn a new GameObject to handle playback
                GameObject soundPlayer = new GameObject($"Sound_{soundName}");
                AudioSource audioSource = soundPlayer.AddComponent<AudioSource>();

                // Configure the AudioSource
                audioSource.clip = clipToPlay;
                audioSource.outputAudioMixerGroup = audioMixerGroup;
                audioSource.panStereo = GetStereoPan(sound);

                // Play the sound and destroy the GameObject after it finishes
                audioSource.Play();
                Destroy(soundPlayer, clipToPlay.length);
            }
        }
        else
        {
            Debug.LogWarning($"Sound '{soundName}' not found!");
        }
    }

    private float GetStereoPan(Sound sound)
    {
        if (sound.playInLeftChannel && !sound.playInRightChannel)
            return -1.0f; // Left channel only
        if (!sound.playInLeftChannel && sound.playInRightChannel)
            return 1.0f;  // Right channel only
        return 0.0f;      // Both channels
    }

    public void SetVolume(float volume)
    {
        audioMixerGroup.audioMixer.SetFloat("SFXVolume", Mathf.Log10(volume) * 20); // Converts [0, 1] to decibel scale
    }
}

==== END OF ..//Assets/Scripts/SoundManager.cs ====

==== START OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====
using UnityEngine;
using TMPro;

public class ReplaceDateTimeText : MonoBehaviour
{
    [SerializeField] private TextMeshProUGUI textMeshPro;

    void Start()
    {
        if (textMeshPro != null)
        {
            string currentDateTime = System.DateTime.Now.ToString("HH:mm");
            textMeshPro.text = textMeshPro.text.Replace("<DATE_TIME>", currentDateTime);
        }
        else
        {
            Debug.LogError("TextMeshProUGUI component is not assigned.");
        }
    }
}

==== END OF ..//Assets/Scripts/ReplaceTextWithDatetime.cs ====

==== START OF ..//Assets/Scripts/DialogueManager.cs ====
using UnityEngine;
using System.Collections.Generic;

public class DialogueManager : MonoBehaviour
{
    public DialogueUI dialogueUI;
    public DialogueAudio dialogueAudio;
    public DialogueLoader dialogueLoader;
    public MainQuestionsHandler mainQuestionsHandler;

    private Dictionary<string, DialogueNode> dialogueNodes = new Dictionary<string, DialogueNode>();
    private DialogueNode currentNode;

    public void StartDialogue()
    {
        dialogueNodes = dialogueLoader.LoadDialogue();
        if (dialogueNodes.Count > 0)
        {
            StartNode("Start");
        }
        else
        {
            Debug.LogError("Dialogue data is empty. Check JSON file.");
        }
    }

    public void StartNode(string nodeId)
    {
        if (string.IsNullOrEmpty(nodeId))
        {
            Debug.LogError("Attempted to start a node with an empty ID.");
            return;
        }

        if (nodeId == "MainQuestions")
        {
            mainQuestionsHandler?.StartMainQuestionsSequence();
            return;
        }

        if (dialogueNodes.ContainsKey(nodeId))
        {
            currentNode = dialogueNodes[nodeId];
            dialogueUI.RefreshView(currentNode, this);
        }
        else
        {
            Debug.LogError($"Node with ID '{nodeId}' not found.");
        }
    }

    public void InjectNodes(List<DialogueNode> nodes)
    {
        foreach (var node in nodes)
        {
            dialogueNodes[node.id] = node;
        }
    }

    public void HandleChoiceSelection(string button)
    {
        if (dialogueUI != null && dialogueUI.choiceContainer.gameObject.activeSelf)
        {
            foreach (var choice in currentNode.choices)
            {
                if (choice.button == button)
                {
                    StartNode(choice.next_node);
                    return;
                }
            }
            Debug.LogWarning($"No choice found for button {button}");
        }
        else if (currentNode != null && currentNode.id.StartsWith("MainPrompts"))
        {
            foreach (var choice in currentNode.choices)
            {
                if (choice.button == button)
                {
                    StartNode(choice.next_node);
                    return;
                }
            }
            Debug.LogWarning($"No choice found for button {button} in MainQuestionsHandler");
        }
        else
        {
            Debug.Log("Choice selection attempted while buttons are not visible.");
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueManager.cs ====

==== START OF ..//Assets/Scripts/EyeManager.cs ====
using System.Collections;
using UnityEngine;

public class EyeManager : MonoBehaviour
{
    public MaterialToggle leftEye; // Reference to the left eye's MaterialToggle
    public MaterialToggle rightEye; // Reference to the right eye's MaterialToggle

    // Turn both eyes on
    public void TurnOnEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(true);
        if (rightEye != null) rightEye.SetToggleState(true);
    }

    // Turn both eyes off
    public void TurnOffEyes()
    {
        if (leftEye != null) leftEye.SetToggleState(false);
        if (rightEye != null) rightEye.SetToggleState(false);
    }

    // Flicker both eyes for a specified duration and frequency
    public void FlickerEyes(float duration, float frequency)
    {
        StartCoroutine(FlickerRoutine(duration, frequency));
    }

    private IEnumerator FlickerRoutine(float duration, float frequency)
    {
        float elapsedTime = 0f;
        bool toggleState = false;

        while (elapsedTime < duration)
        {
            toggleState = !toggleState;

            if (leftEye != null) leftEye.SetToggleState(toggleState);
            if (rightEye != null) rightEye.SetToggleState(toggleState);

            yield return new WaitForSeconds(frequency);
            elapsedTime += frequency;
        }

        // Ensure eyes are turned off at the end of flicker
        TurnOffEyes();
    }
}

==== END OF ..//Assets/Scripts/EyeManager.cs ====

==== START OF ..//Assets/Scripts/ShowForSeconds.cs ====
using UnityEngine;

public class ShowForSeconds : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/ShowForSeconds.cs ====

==== START OF ..//Assets/Scripts/DialogueNode.cs ====
using System.Collections.Generic;
using UnityEngine;

[System.Serializable]
public class DialogueNode
{
    public string id;
    public string speaker;
    public object body_text;
    public List<Choice> choices;
    public bool text_to_speech;
    public string play_sound;
    public string animation;

   public string GetBodyText()
{
    if (body_text == null)
    {
        Debug.LogWarning($"DialogueNode {id} has no body_text field.");
        return "Missing text";
    }

    if (body_text is string singleText)
    {
        return singleText;
    }
    else if (body_text is List<object> textList && textList.Count > 0)
    {
        return textList[Random.Range(0, textList.Count)].ToString();
    }
    else if (body_text is List<string> stringList && stringList.Count > 0)
    {
        return stringList[Random.Range(0, stringList.Count)];
    }
    Debug.LogError($"Unexpected body_text format in node {id}");
    return "Invalid format";
}

    [System.Serializable]
    public class Choice
    {
        public string text;
        public string next_node;
        public string button;
    }
}

==== END OF ..//Assets/Scripts/DialogueNode.cs ====

==== START OF ..//Assets/Scripts/DialogueAudio.cs ====
using UnityEngine;
using System.Collections;

public class DialogueAudio : MonoBehaviour
{
    public AudioSource audioSource;
    private bool HasPlayedScannerPrompt = false;

    public void PlayVoice(string nodeId, System.Action onComplete)
    {
        string[] voicePaths = new string[]
        {
            $"sounds/voice/voice_{nodeId}",
            $"sounds/voice/{nodeId}"
        };

        foreach (var path in voicePaths)
        {
            AudioClip clip = Resources.Load<AudioClip>(path);
            if (clip != null)
            {
                audioSource.clip = clip;
                audioSource.Play();
                StartCoroutine(PlayClip(clip.length, onComplete));
                Debug.Log($"Playing voice file: {path}");
                return;
            }
        }

        Debug.Log($"No voice file found for {nodeId}");
        onComplete?.Invoke();
    }

    private IEnumerator PlayClip(float duration, System.Action onComplete)
    {
        yield return new WaitForSeconds(duration);
        Debug.Log("audioSource.clip.name " + audioSource.clip.name);
        Debug.Log("HasPlayedScannerPrompt " + HasPlayedScannerPrompt);
        if (audioSource.clip.name.Contains("MainPrompts_") && !HasPlayedScannerPrompt)
        {
            AudioClip scannerPrompt = Resources.Load<AudioClip>("sounds/voice/SCANNER_PROMPT");
            if (scannerPrompt != null)
            {
                audioSource.clip = scannerPrompt;
                audioSource.Play();
                HasPlayedScannerPrompt = true;
                yield return new WaitForSeconds(scannerPrompt.length);
            }
        }
        onComplete?.Invoke();
    }
}

==== END OF ..//Assets/Scripts/DialogueAudio.cs ====

==== START OF ..//Assets/Scripts/LerpOnStart.cs ====
using UnityEngine;
using UnityEngine.Events;

public class LerpOnStart : MonoBehaviour
{
    public Vector3 startPosition;
    public Vector3 targetPosition;
    public float duration = 1.0f;

    public UnityEvent onLerpStart;
    public UnityEvent onLerpEnd;

    private float elapsedTime = 0.0f;
    private bool isLerping = false;

    void Start()
    {
        transform.localPosition = startPosition;
    }

    public void StartLerp()
    {
        elapsedTime = 0.0f;
        isLerping = true;
        onLerpStart?.Invoke();
    }

    void Update()
    {
        if (isLerping)
        {
            elapsedTime += Time.deltaTime;
            float t = Mathf.Clamp01(elapsedTime / duration);
            transform.localPosition = Vector3.Lerp(startPosition, targetPosition, t);

            if (t >= 1.0f)
            {
                isLerping = false;
                onLerpEnd?.Invoke();
            }
        }
    }
}

==== END OF ..//Assets/Scripts/LerpOnStart.cs ====

==== START OF ..//Assets/Scripts/PalmScanner.cs ====
using System.IO.Ports;
using UnityEngine;
using UnityEngine.UI;

public class PalmScanner : MonoBehaviour
{
    public Image connectionIcon;
    private SerialPort serialPort;
    public string portName = "/dev/ttyUSB0";  // Adjust for Linux
    public int baudRate = 9600;
    private bool isConnected = false;
    public static bool button1Pressed = false;
    public static bool button2Pressed = false;
    private float button1ResetTime;
    private float button2ResetTime;
    private const float resetDelay = 1f;

    void Start()
    {
        TryInitializeScanner();
    }

    void TryInitializeScanner()
    {
        try
        {
            if (serialPort != null && serialPort.IsOpen)
            {
                serialPort.Close();
            }

            serialPort = new SerialPort(portName, baudRate);
            serialPort.Open();
            serialPort.ReadTimeout = 100;
            isConnected = serialPort.IsOpen;
        }
        catch (System.Exception ex)
        {
            isConnected = false;
            serialPort = null;
            UnityEngine.Debug.LogError($"Failed to open serial port: {ex.Message}");
        }
        UpdateIconColor();
    }

    void Update()
    {
        if (serialPort == null || !isConnected)
        {
            return;
        }

        try
        {
            if (serialPort.BytesToRead > 0)
            {
                string receivedData = serialPort.ReadLine().Trim();
                UnityEngine.Debug.Log($"Palm Scanner received: {receivedData}");

                if (receivedData == "1")
                {
                    button1Pressed = true;
                    button1ResetTime = Time.time + resetDelay;
                }
                else if (receivedData == "2")
                {
                    button2Pressed = true;
                    button2ResetTime = Time.time + resetDelay;
                }
            }
        }
        catch (System.Exception ex)
        {
            UnityEngine.Debug.LogError($"Error reading from serial port: {ex.Message}");
        }

        if (button1Pressed && Time.time >= button1ResetTime)
        {
            button1Pressed = false;
        }

        if (button2Pressed && Time.time >= button2ResetTime)
        {
            button2Pressed = false;
        }
    }

    void UpdateIconColor()
    {
        if (connectionIcon != null)
        {
            connectionIcon.color = isConnected ? Color.yellow : Color.black;
        }
    }

    void OnApplicationQuit()
    {
        if (serialPort != null && serialPort.IsOpen)
        {
            serialPort.Close();
        }
    }
}

==== END OF ..//Assets/Scripts/PalmScanner.cs ====

==== START OF ..//Assets/Scripts/CheckIfActive.cs ====
using UnityEngine;

public class CheckIfActive : MonoBehaviour
{
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}

==== END OF ..//Assets/Scripts/CheckIfActive.cs ====

==== START OF ..//Assets/Scripts/DialogueUI.cs ====
using UnityEngine;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;

public class DialogueUI : MonoBehaviour
{
    public TMP_Text dialogueText;
    public TMP_Text speakerText;
    public Transform choiceContainer;
    public GameObject choiceButtonPrefab;
    public DialogueController dialogueController;

    private bool previousButton1State = false;
    private bool previousButton2State = false;

    private bool ChoicesEnabled = false;

 void Update()
{
    if ( choiceContainer.gameObject.activeInHierarchy)
    {
        if (PalmScanner.button1Pressed && !previousButton1State)
        {
            previousButton1State = true;
            HandleChoiceSelection("1");
        }
        else if (!PalmScanner.button1Pressed)
        {
            previousButton1State = false;
        }

        if (PalmScanner.button2Pressed && !previousButton2State)
        {
            previousButton2State = true;
            HandleChoiceSelection("2");
        }
        else if (!PalmScanner.button2Pressed)
        {
            previousButton2State = false;
        }
    }
}


    public void RefreshView(DialogueNode node, DialogueManager manager)
    {
        choiceContainer.gameObject.SetActive(false);
        Debug.Log($"Refreshing view for node ID: {node.id}");
        Debug.Log($"Setting dialogue title: {node.speaker}, body: {node.GetBodyText()}");

        dialogueController.SetDialogue(node.speaker ?? "", node.GetBodyText() ?? "");

        ClearChoices();
        
        Debug.Log("Cleared previous choices.");

        if (node.text_to_speech)
        {
            Debug.Log($"Text-to-speech enabled for node ID: {node.id}, attempting to play voice.");
            manager.dialogueAudio.PlayVoice(node.id, () => EnableChoices(node.choices, manager));
        }
        else
        {
            Debug.Log("Text-to-speech disabled, enabling choices immediately.");
            EnableChoices(node.choices, manager);
        }
    }

void Start(){
    choiceContainer.gameObject.SetActive(false);
}
    void ClearChoices()
    {
        choiceContainer.gameObject.SetActive(false);
        foreach (Transform child in choiceContainer)
        {
            Destroy(child.gameObject);
        }
        Debug.Log("Choice container cleared.");
    }

    void EnableChoices(List<DialogueNode.Choice> choices, DialogueManager manager)
    {

        foreach (var choice in choices)
        {
            if (!string.IsNullOrEmpty(choice.text) && !string.IsNullOrEmpty(choice.button))
            {
                Debug.Log($"Adding choice: {choice.text} with button: {choice.button}");
                GameObject button = Instantiate(choiceButtonPrefab, choiceContainer);
                TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();
                buttonText.text = $"[{choice.button}] {choice.text}";
                button.GetComponent<Button>().onClick.AddListener(() => manager.HandleChoiceSelection(choice.button));
            }
            else
            {
                Debug.LogWarning("Encountered a choice with missing text or button, skipping.");
            }
        }
          choiceContainer.gameObject.SetActive(true);
    }

    void HandleChoiceSelection(string buttonPressed)
    {

        Debug.Log("==============================================/n Tried to press button for " + buttonPressed);

        foreach (Transform child in choiceContainer)
        {
            Button button = child.GetComponent<Button>();
            TMP_Text buttonText = button.GetComponentInChildren<TMP_Text>();

Debug.Log("buttonText.text.Contains($\"[{buttonPressed}]\")) " + buttonText.text.Contains($"[{buttonPressed}]")) ;
            if (buttonText.text.Contains($"[{buttonPressed}]"))
            {
                Debug.Log($"Simulating click for button: {buttonPressed}");
                button.onClick.Invoke();
                choiceContainer.gameObject.SetActive(false);
                return;
            }
        }
    }
}

==== END OF ..//Assets/Scripts/DialogueUI.cs ====

==== START OF ..//Assets/Scripts/DebugConsole.cs ====
using UnityEngine;
using TMPro;

public class DebugConsole : MonoBehaviour
{

    public GameObject debugConsoleBG;
    public TextMeshProUGUI debugText;
    private bool isVisible = false;
    private string logContent = "";

    void Awake()
    {
        if (debugText == null)
        {
            Debug.LogError("DebugConsole: TextMeshProUGUI reference not set!");
            return;
        }
        
        debugConsoleBG.gameObject.SetActive(false);
        debugText.gameObject.SetActive(false);
        Application.logMessageReceived += HandleLog;
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.L))
        {
            isVisible = !isVisible;
            debugText.gameObject.SetActive(isVisible);
            debugConsoleBG.gameObject.SetActive(isVisible);
        }
    }

    void HandleLog(string logString, string stackTrace, LogType type)
    {
        logContent += logString + "\n";
        debugText.text = logContent;
    }

    void OnDestroy()
    {
        Application.logMessageReceived -= HandleLog;
    }
}

==== END OF ..//Assets/Scripts/DebugConsole.cs ====

==== START OF ..//Assets/Scripts/Console.cs ====
using UnityEngine;

public static class Console
{
    public static void Log(string message)
    {
#if UNITY_EDITOR
        Debug.Log(message);
#endif
    }

    public static void LogWarning(string message)
    {
#if UNITY_EDITOR
        Debug.LogWarning(message);
#endif
    }

    public static void LogError(string message)
    {
#if UNITY_EDITOR
        Debug.LogError(message);
#endif
    }
}

==== END OF ..//Assets/Scripts/Console.cs ====

==== START OF ..//Assets/Scripts/BootSequence.cs ====
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.Events;

public class BootSequence : MonoBehaviour
{
    public TextMeshProUGUI bootTextBox; // Text box for displaying boot sequence
    public string bootTextFileName = "Boot_sequence";

    [Header("Typing Speed (characters per second; higher = faster)")]
    public float minTypingSpeedCharactersPerSecond = 300f;
    public float maxTypingSpeedCharactersPerSecond = 700f;

    [Header("Line Delay (seconds; higher = slower)")]
    public float minLineDelaySeconds = 0.3f;
    public float maxLineDelaySeconds = 1.0f;

    public int lineLimit = 15; // Max number of lines displayed

    [Header("On Boot Complete")]
    public float delayAfterLastLineSeconds = 1.5f;
    public UnityEvent onBootSequenceComplete;

    private List<string> bootText = new List<string>();
    private List<string> displayedLines = new List<string>();
    private int lineIndex = 0;
    private float typingSpeedCharactersPerSecond;
    private float typingAccumulator = 0f;
    private int currentChar = 0;
    private string currentLine = "";

    void Start()
    {
        LoadTextFromFile();
        typingSpeedCharactersPerSecond = Random.Range(minTypingSpeedCharactersPerSecond, maxTypingSpeedCharactersPerSecond);

        if (bootText.Count > 0)
        {
            StartCoroutine(DisplayNextLine());
        }
        else
        {
            Console.Log("No text found in the boot sequence file!");
        }
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Console.Log("User skip activated");
            onBootSequenceComplete?.Invoke();
        }
    }

    private void LoadTextFromFile()
    {
        TextAsset file = Resources.Load<TextAsset>(bootTextFileName);
        if (file != null)
        {
            bootText = new List<string>(file.text.Split('\n'));
            //Console.Log("Boot sequence text loaded successfully.");
            //Console.Log(string.Join(", ", bootText));
        }
        else
        {
            Console.Log("Failed to load text file '" + bootTextFileName + "'. Ensure it's in the Resources folder.");
        }
    }

    private IEnumerator DisplayNextLine()
    {
        while (lineIndex < bootText.Count)
        {
            currentLine = bootText[lineIndex];
            lineIndex++;
            currentChar = 0;
            AddNewline();

            while (currentChar < currentLine.Length)
            {
                typingAccumulator += Time.deltaTime * typingSpeedCharactersPerSecond;
                int charsToAdd = Mathf.FloorToInt(typingAccumulator);
                typingAccumulator -= charsToAdd;

                charsToAdd = Mathf.Min(charsToAdd, currentLine.Length - currentChar);

                if (charsToAdd > 0)
                {
                    displayedLines[displayedLines.Count - 1] += currentLine.Substring(currentChar, charsToAdd);
                    currentChar += charsToAdd;
                    bootTextBox.text = string.Join("\n", displayedLines);
                }
                yield return null;
            }

            float lineDelaySeconds = Random.Range(minLineDelaySeconds, maxLineDelaySeconds);
            yield return new WaitForSeconds(lineDelaySeconds);
        }

        Console.Log("Finished displaying all lines.");

        yield return new WaitForSeconds(delayAfterLastLineSeconds);
        onBootSequenceComplete?.Invoke();
    }

    private void AddNewline()
    {
        displayedLines.Add("");
        if (displayedLines.Count > lineLimit)
        {
            displayedLines.RemoveAt(0);
        }
        bootTextBox.text = string.Join("\n", displayedLines);
    }
}

==== END OF ..//Assets/Scripts/BootSequence.cs ====

==== START OF ..//Assets/Scripts/MaterialToggle.cs ====
using UnityEngine;

public class MaterialToggle : MonoBehaviour
{
    public Material onMaterial; // Material to use when "on"
    public Material offMaterial; // Material to use when "off"

    private Renderer objectRenderer;
    private bool isOn = false;

    void Start()
    {
        objectRenderer = GetComponent<Renderer>();

        // Set the initial material based on the isOn state
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }

    public void SetToggleState(bool isOn)
    {
        this.isOn = isOn;
        if (objectRenderer != null)
        {
            objectRenderer.material = isOn ? onMaterial : offMaterial;
        }
    }
}

==== END OF ..//Assets/Scripts/MaterialToggle.cs ====

==== START OF ..//Assets/Scripts/QuitGame.cs ====
using UnityEngine;

public class QuitGame : MonoBehaviour
{
   void Update()
    {
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            Application.Quit();
        }
    }
}

==== END OF ..//Assets/Scripts/QuitGame.cs ====

==== START OF ..//Assets/Scripts/RestartScene.cs ====
using UnityEngine;
using UnityEngine.SceneManagement;

public class RestartScene : MonoBehaviour
{
    // Method to restart the current scene
    public void RestartCurrentScene()
    {
        // Get the active scene and reload it
        SceneManager.LoadScene(SceneManager.GetActiveScene().name);
    }
}

==== END OF ..//Assets/Scripts/RestartScene.cs ====

==== START OF ..//Assets/Scripts/UnitySerialPort.cs ====
// <copyright file="UnitySerialPort.cs" company="dyadica.co.uk">
// Copyright (c) 2010, 2014 All Right Reserved, http://www.dyadica.co.uk

// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// </copyright>

// <author>SJB</author>
// <email>github@dyadica.co.uk</email>
// <date>04.09.2013</date>
// <summary>A MonoBehaviour type class containing several functions which can be utilised 
// to perform serial communication within Unity3D</summary>

// This code was updated 04.03.2014 to include Notification Events. Please see:
// http://www.dyadica.co.uk/journal/adding-events-to-the-serialport-script for
// more information.

// This code was updated 03.02.2022 to include Notification Events. My website is
// down so please see the readme.md for more information!

using UnityEngine;
using System.Collections;

using System.IO.Ports;
using System;

using System.Threading;

using System.Collections.Generic;

// new Text Mesh Pro text
using TMPro;

public class UnitySerialPort : MonoBehaviour
{
    // Init a static reference if script is to be accessed by others when used in a 
    // none static nature eg. its dropped onto a gameObject. The use of "Instance"
    // allows access to public vars as such as those available to the unity editor.

    public static UnitySerialPort Instance;

    #region Properties

    // The serial port

    public SerialPort SerialPort;

    // Thread for thread version of port
    Thread SerialLoopThread;

    [Header("SerialPort")]

    // Current com port and set of default
    public string ComPort = "COM5";

    // Current baud rate and set of default
    // 300, 600, 1200, 2400, 4800, 9600, 14400, 19200, 28800, 38400, 57600, 115200
    public int BaudRate = 115200;

    // The parity-checking protocol.
    public Parity Parity = Parity.None;

    // The standard number of stopbits per byte.
    public StopBits StopBits = StopBits.One;

    // The standard length of data bits per byte.
    public int DataBits = 8;

    // The state of the Data Terminal Ready(DTR) signal during serial communication.
    public bool DtrEnable;
    
    // Whether or not the Request to Send(RTS) signal is enabled during serial communication.
    public bool RtsEnable;    

    // Holder for status report information

    private string portStatus = "";
    public string PortStatus
    {
        get { return portStatus; }
        set { portStatus = value; }
    }

    // Read and write timeouts

    public int ReadTimeout = 10;
    public int WriteTimeout = 10;

    // Property used to run/keep alive the serial thread loop

    private bool isRunning = false;
    public bool IsRunning
    {
        get { return isRunning; }
        set { isRunning = value; }
    }

    // Set the gui to show ready

    private string rawData = "Ready";
    public string RawData
    {
        get { return rawData; }
        set { rawData = value; }
    }

    // Storage for parsed incoming data

    private string[] chunkData;
    public string[] ChunkData
    {
        get { return chunkData; }
        set { chunkData = value; }
    }

    [Header("GUI Fields")]

    // Refs populated by the editor inspector for default gui
    // functionality if script is to be used in a non-static
    // context.

    public TMP_Text ComStatusText;
    public TMP_Text RawDataText;
    public TMP_Text StatusMsgBox;

    // public TMP_InputField OutputString;

    // Define a delegate for our event to use. Delegates 
    // encapsulate both an object instance and a method 
    // and are similar to c++ pointers.

    public delegate void SerialDataParseEventHandler(string[] data, string rawData);

    // Define the event that utilizes the delegate to
    // fire off a notification to all registered objs 

    public static event SerialDataParseEventHandler SerialDataParseEvent;

    // Delegate and event for serialport open notification

    public delegate void SerialPortOpenEventHandler();
    public static event SerialPortOpenEventHandler SerialPortOpenEvent;

    // Delegate and event for serialport close notification

    public delegate void SerialPortCloseEventHandler();
    public static event SerialPortCloseEventHandler SerialPortCloseEvent;

    // Delegate and event for serialport sentData notification

    public delegate void SerialPortSentDataEventHandler(string data);
    public static event SerialPortSentDataEventHandler SerialPortSentDataEvent;

    // Delegate and event for serialport sentLineData notification

    public delegate void SerialPortSentLineDataEventHandler(string data);
    public static event SerialPortSentLineDataEventHandler SerialPortSentLineDataEvent;
   
    public enum LoopMethods
    { Threading, Coroutine }

    [Header("Options")]
    [SerializeField]
    public LoopMethods LoopMethod =
        LoopMethods.Coroutine;

    // If set to true then open the port when the start
    // event is called.

    public bool OpenPortOnStart = false;
    public bool ShowDebugs = true;
    
    // List of all com ports available on the system

    private ArrayList comPorts =
        new ArrayList();

    [Header("Misc")]
    public List<string> ComPorts =
        new List<string>();

    [Header("Data Read")]    

    public ReadMethod ReadDataMethod = 
        ReadMethod.ReadLine;
    public enum ReadMethod
    {
        ReadLine,
        ReadToChar
    }

    public string Delimiter;
    public char Separator;

   


    #endregion Properties

    #region Unity Frame Events

    /// <summary>
    /// The awake call is used to populate refs to the gui elements used in this 
    /// example. These can be removed or replaced if needed with bespoke elements.
    /// This will not affect the functionality of the system. If we are using awake
    /// then the script is being run non staticaly ie. its initiated and run by 
    /// being dropped onto a gameObject, thus enabling the game loop events to be 
    /// called e.g. start, update etc.
    /// </summary>
    void Awake()
    {
        // Define the script Instance

        Instance = this;

        // If we have used the editor inspector to populate any included gui
        // elements then lets initiate them and set some default values.

        // Details if the port is open or closed

        if (ComStatusText != null)
        { ComStatusText.text = "ComStatus: Closed"; }
    }

    /// <summary>
    /// The start call is used to populate a list of available com ports on the
    /// system. The correct port can then be selected via the respective guitext
    /// or a call to UpdateComPort();
    /// </summary>
    void Start()
    {
        // Register for a notification of the open port event

        SerialPortOpenEvent +=
            new SerialPortOpenEventHandler(UnitySerialPort_SerialPortOpenEvent);

        // Register for a notification of the close port event

        SerialPortCloseEvent +=
            new SerialPortCloseEventHandler(UnitySerialPort_SerialPortCloseEvent);

        // Register for a notification of data sent

        SerialPortSentDataEvent +=
            new SerialPortSentDataEventHandler(UnitySerialPort_SerialPortSentDataEvent);

        // Register for a notification of data sent

        SerialPortSentLineDataEvent +=
            new SerialPortSentLineDataEventHandler(UnitySerialPort_SerialPortSentLineDataEvent);

        // Register for a notification of the SerialDataParseEvent

        SerialDataParseEvent +=
            new SerialDataParseEventHandler(UnitySerialPort_SerialDataParseEvent);

        // Population of comport list via system.io.ports

        PopulateComPorts();

        // If set to true then open the port. You must 
        // ensure that the port is valid etc. for this! 

        if (OpenPortOnStart) { OpenSerialPort(); }
    }

    /// <summary>
    /// This function is called when the MonoBehaviour will be destroyed.
    /// OnDestroy will only be called on game objects that have previously
    /// been active.
    /// </summary>
    void OnDestroy()
    {
        // If we are registered for a notification of the 
        // SerialPort events then remove the registration

        if (SerialDataParseEvent != null)
            SerialDataParseEvent -= UnitySerialPort_SerialDataParseEvent;

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent -= UnitySerialPort_SerialPortOpenEvent;

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent -= UnitySerialPort_SerialPortCloseEvent;

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent -= UnitySerialPort_SerialPortSentDataEvent;

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent -= UnitySerialPort_SerialPortSentLineDataEvent;
    }

    /// <summary>
    /// The update frame call is used to provide caps for sending data to the arduino
    /// triggered via keypress. This can be replaced via use of the static functions
    /// SendSerialData() & SendSerialDataAsLine(). Additionaly this update uses the
    /// RawData property to update the gui. Again this can be removed etc.
    /// </summary>
    void Update()
    {
        // Check if the serial port exists and is open
        if (SerialPort == null || SerialPort.IsOpen == false) { return; }

        // Example calls from system to the arduino. For more detail on the
        // structure of the calls see:
        // http://www.dyadica.co.uk/journal/simple-serial-string-parsing/

        //try
        //{
        //    // Here we have some sample usage scenarios that
        //    // demo the operation of the UnitySerialPort. In
        //    // order to use these you must first ensure that
        //    // the custom inputs are defined via:

        //    // Edit > Project Settings > Input

        //    if (Input.GetButtonDown("SendData"))
        //    { SendSerialDataAsLine(OutputString.text); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,1" string will call functionA and pass a
        //    // char value of 1
        //    if (Input.GetButtonDown("Key1"))
        //    { SendSerialDataAsLine("A,1"); }

        //    // Example of sending key 1 press event to arduino.
        //    // The "A,2" string will call functionA and pass a
        //    // char value of 2
        //    if (Input.GetButtonDown("Key2"))
        //    { SendSerialDataAsLine("A,2"); }

        //    // Example of sending space press event to arduino
        //    if (Input.GetButtonDown("Key3"))
        //    { SendSerialDataAsLine(""); }
        //}
        //catch (Exception ex)
        //{
        //    // Failed to send serial data
        //    Debug.Log("Error 6: " + ex.Message.ToString());
        //}

        try
        {
            // If we have set a GUI Text object then update it. This can only be
            // run on the thread that initialised the object thus cnnot be run
            // in the ParseSerialData() call below... Unless run as a coroutine!

            // I have also included other raw data examples in GUIManager.cs         

            // RawDataText is null/none by default for examples (see GUIManager.cs)
            if (RawDataText != null)
                RawDataText.text = RawData; 
        }
        catch (Exception ex)
        {
            // Failed to update serial data
            Debug.Log("Error 7: " + ex.Message.ToString());
        }
    }

    /// <summary>
    /// Clean up the thread and close the port on application close event.
    /// </summary>
    void OnApplicationQuit()
    {
        // Call to cloase the serial port
        CloseSerialPort();

        Thread.Sleep(100);

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        Thread.Sleep(100);
    }

    #endregion Unity Frame Events

    #region Notification Events

    /// <summary>
    /// Data parsed serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    /// <param name="RawData">string[]</param>
    void UnitySerialPort_SerialDataParseEvent(string[] Data, string RawData)
    {       
        // Not fired via portStatus to avoid hiding other messages from the GUI
        if (ShowDebugs)
            print("Data Recieved via port: " + RawData);
    }

    /// <summary>
    /// Open serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortOpenEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now open!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Close serialport notification event
    /// </summary>
    void UnitySerialPort_SerialPortCloseEvent()
    {
        portStatus = "The serialport:" + ComPort + " is now closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentDataEvent(string Data)
    {
        portStatus = "Sent data: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Send data with "\n" serialport notification event
    /// </summary>
    /// <param name="Data">string</param>
    void UnitySerialPort_SerialPortSentLineDataEvent(string Data)
    {
        portStatus = "Sent data as line: " + Data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Notification Events

    #region Object Serial Port

    /// <summary>
    /// Opens the defined serial port and starts the serial thread used
    /// to catch and deal with serial events.
    /// </summary>
    public void OpenSerialPort()
    {
        try
        {
            // Initialise the serial port
            SerialPort = new SerialPort(ComPort, BaudRate, Parity, DataBits, StopBits);

            SerialPort.ReadTimeout = ReadTimeout;
            SerialPort.WriteTimeout = WriteTimeout;

            SerialPort.DtrEnable = DtrEnable;
            SerialPort.RtsEnable = RtsEnable;

            // Open the serial port
            SerialPort.Open();

            // Update the gui if applicable
            if (Instance != null && Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Open"; }

            if (LoopMethod == LoopMethods.Coroutine)
            {
                if (isRunning)
                {
                    // TCoroutine is already running so kill it!?
                    StopSerialCoroutine();
                }

                // Restart it once more
                StartSerialCoroutine();
            }

            if (LoopMethod == LoopMethods.Threading)
            {
                if (isRunning)
                {
                    // Thread is already running so kill it!?
                    StopSerialThreading();
                }

                // Restart it once more
                StartSerialThread();
            }

            portStatus = "The serialport is now open!";

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }
        catch (Exception ex)
        {
            // Failed to open com port or start serial thread
            Debug.Log("Error 1: " + ex.Message.ToString());
        }

        if (SerialPortOpenEvent != null)
            SerialPortOpenEvent();
    }

    /// <summary>
    /// Cloases the serial port so that changes can be made or communication
    /// ended.
    /// </summary>
    public void CloseSerialPort()
    {
        try
        {
            // Close the serial port
            SerialPort.Close();

            // Update the gui if applicable
            if (Instance.ComStatusText != null)
            { Instance.ComStatusText.text = "ComStatus: Closed"; }
        }
        catch (Exception ex)
        {
            if (SerialPort == null || SerialPort.IsOpen == false)
            {
                // Failed to close the serial port. Uncomment if
                // you wish but this is triggered as the port is
                // already closed and or null.

                // Debug.Log("Error 2A: " + "Port already closed!");
            }
            else
            {
                // Failed to close the serial port
                Debug.Log("Error 2B: " + ex.Message.ToString());
            }
        }

        if (LoopMethod == LoopMethods.Coroutine)
            StopSerialCoroutine();

        if (LoopMethod == LoopMethods.Threading)
            StopSerialThreading();

        portStatus ="Serial port closed!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Trigger a port closed notification

        if (SerialPortCloseEvent != null)
            SerialPortCloseEvent();
    }

    #endregion Object Serial Port

    #region Serial Threading

    void StartSerialThread()
    {
        isRunning = true;

        SerialLoopThread = new Thread(SerialThreadLoop);
        SerialLoopThread.Start();
    }

    void SerialThreadLoop()
    {
        while (isRunning)
        {
            if (isRunning == false)
                break;

            // Run the generic loop
            GenericSerialLoop();
        }

      portStatus = "Ending Serial Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the thread and "over" kill
    /// off any instance
    /// </summary>
    public void StopSerialThreading()
    {
        isRunning = false;

        // this should timeout the thread

        Thread.Sleep(100);

        // otherwise...

        if (SerialLoopThread != null && SerialLoopThread.IsAlive)
            SerialLoopThread.Abort();

        Thread.Sleep(100);

        if (SerialLoopThread != null)
            SerialLoopThread = null;

        // Reset the serial port to null

        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)

        portStatus = "Ended Serial Loop Thread!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Threading

    #region Serial Coroutine

    /// <summary>
    /// Function used to start coroutine for reading serial 
    /// data.
    /// </summary>
    public void StartSerialCoroutine()
    {
        isRunning = true;

        StartCoroutine("SerialCoroutineLoop");
    }

    /// <summary>
    /// A Coroutine used to recieve serial data thus not 
    /// affecting generic unity playback etc.
    /// </summary>
    public IEnumerator SerialCoroutineLoop()
    {
        while (isRunning)
        {
            GenericSerialLoop();
            yield return null;
        }

       portStatus = "Ending Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to stop the coroutine and kill
    /// off any instance
    /// </summary>
    public void StopSerialCoroutine()
    {
        isRunning = false;

        Thread.Sleep(100);

        try
        {
            StopCoroutine("SerialCoroutineLoop");
        }
        catch (Exception ex)
        {
            portStatus = "Error 2A: " + ex.Message.ToString();

            if (ShowDebugs)
                ShowDebugMessages(portStatus);
        }

        // Reset the serial port to null
        if (SerialPort != null)
        { SerialPort = null; }

        // Update the port status... just in case :)
        portStatus = "Ended Serial Loop Coroutine!";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    #endregion Serial Coroutine

    /// <summary>
    /// The serial thread loop & the coroutine loop both utilise
    /// the same code with the exception of the null return on 
    /// the coroutine, so we share it here.
    /// </summary>
    private void GenericSerialLoop()
    {
        try
        {
            // Check that the port is open. If not skip and do nothing
            if (SerialPort.IsOpen)
            {
                // Read serial data until...

                string rData = string.Empty;

                // swap between the ReadLine or ReadTo
                switch (ReadDataMethod)
                {
                    case ReadMethod.ReadLine:
                        rData = SerialPort.ReadLine();
                        break;
                    case ReadMethod.ReadToChar:
                        rData = SerialPort.ReadTo(Delimiter);
                        break;
                }

                // If the data is valid then do something with it
                if (rData != null && rData != "")
                {
                    // Store the raw data
                    RawData = rData;
                    // split the raw data into chunks via ',' and store it
                    // into a string array
                    ChunkData = RawData.Split(Separator);

                    // Or you could call a function to do something with
                    // data e.g.
                    ParseSerialData(ChunkData, RawData);
                }
            }
        }
        catch (TimeoutException)
        {
            // This will be triggered lots with the coroutine method
        }
        catch (Exception ex)
        {
            // This could be thrown if we close the port whilst the thread 
            // is reading data. So check if this is the case!
            if (SerialPort.IsOpen)
            {
                // Something has gone wrong!
                Debug.Log("Error 4: " + ex.Message.ToString());
            }
            else
            {
                // Error caused by closing the port whilst in use! This is 
                // not really an error but uncomment if you wish.

                Debug.Log("Error 5: Port Closed Exception!");
            }
        }
    }

    #region Methods

    /// <summary>
    /// Function used to send string data over serial with
    /// an included line return
    /// </summary>
    /// <param name="data">string</param>
    public void SendSerialDataAsLine(string data)
    {
        if (SerialPort != null)
        { SerialPort.WriteLine(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentLineDataEvent != null)
            SerialPortSentLineDataEvent(data);        
    }

    /// <summary>
    /// Function used to send string data over serial without
    /// a line return included.
    /// </summary>
    /// <param name="data"></param>
    public void SendSerialData(string data)
    {
        if (SerialPort != null)
        { SerialPort.Write(data); }

        portStatus = "Sent data: " + data;

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // throw a sent data notification

        if (SerialPortSentDataEvent != null)
            SerialPortSentDataEvent(data);
    }

    /// <summary>
    /// Function used to filter and act upon the data recieved. You can add
    /// bespoke functionality here.
    /// </summary>
    /// <param name="data">string[] of raw data seperated into chunks via ','</param>
    /// <param name="rawData">string of raw data</param>
    private void ParseSerialData(string[] data, string rawData)
    {

        // Fire a notification to all registered objects. Before we do
        // this however, first double check that we have some valid
        // data here so this only has to be performed once and not on
        // each object notified.

        if (data != null && rawData != string.Empty)
        {
            if (SerialDataParseEvent != null)
                SerialDataParseEvent(data, rawData);
        }
    }

    /// <summary>
    /// Function that utilises system.io.ports.getportnames() to populate
    /// a list of com ports available on the system.
    /// </summary>
    public void PopulateComPorts()
    {
        // Loop through all available ports and add them to the list
        foreach (string cPort in SerialPort.GetPortNames())
        {
            ComPorts.Add(cPort);

            comPorts.Add(cPort);

            // Debug.Log(cPort.ToString());
        }

        // Update the port status just in case :)
        portStatus = "ComPort list population complete";

        if (ShowDebugs)
            ShowDebugMessages(portStatus);
    }

    /// <summary>
    /// Function used to update the current selected com port
    /// </summary>
    public string UpdateComPort()
    {
        // If open close the existing port
        if (SerialPort != null && SerialPort.IsOpen)
        { CloseSerialPort(); }

        // Find the current id of the existing port within the
        // list of available ports
        int currentComPort = comPorts.IndexOf(ComPort);

        // check against the list of ports and get the next one.
        // If we have reached the end of the list then reset to zero.
        if (currentComPort + 1 <= comPorts.Count - 1)
        {
            // Inc the port by 1 to get the next port
            ComPort = (string)comPorts[currentComPort + 1];
        }
        else
        {
            // We have reached the end of the list reset to the
            // first available port.
            ComPort = (string)comPorts[0];
        }

        // Update the port status just in case :)
        portStatus = "ComPort set to: " + ComPort.ToString();

        if (ShowDebugs)
            ShowDebugMessages(portStatus);

        // Return the new ComPort just in case
        return ComPort;
    }

    /// <summary>
    /// What it says on the tin!
    /// </summary>
    /// <param name="portStatus">string</param>
    public void ShowDebugMessages(string portStatus)
    {
        if (StatusMsgBox != null)
            StatusMsgBox.text = portStatus;

        print(portStatus);
    }

    #endregion Methods
}

==== END OF ..//Assets/Scripts/UnitySerialPort.cs ====

